/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@flatten-js/core@1.6.2/dist/main.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const t=!0,e=!1,n={CCW:-1,CW:1,NOT_ORIENTABLE:0},i=2*Math.PI,r=1,s=0,o=2,a=1,l=2,h=0,c=1,f=2;var u=Object.freeze({__proto__:null,BOUNDARY:o,CCW:t,CONTAINS:3,CW:false,END_VERTEX:f,INSIDE:r,INTERLACE:4,NOT_VERTEX:h,ORIENTATION:n,OUTSIDE:s,OVERLAP_OPPOSITE:2,OVERLAP_SAME:1,PIx2:i,START_VERTEX:c});let p=1e-6;function d(t){p=t}function g(){return p}function m(t){return t<p&&t>-p}function _(t,e){return t-e<p&&t-e>-p}function x(t,e){return t-e>p}function v(t,e){return t-e<-p}var E=Object.freeze({__proto__:null,DECIMALS:3,EQ:_,EQ_0:m,GE:function(t,e){return t-e>-p},GT:x,LE:function(t,e){return t-e<p},LT:v,getTolerance:g,setTolerance:d});let y={Utils:E,Errors:void 0,Matrix:void 0,Planar_set:void 0,Point:void 0,Vector:void 0,Line:void 0,Circle:void 0,Segment:void 0,Arc:void 0,Box:void 0,Edge:void 0,Face:void 0,Ray:void 0,Ray_shooting:void 0,Multiline:void 0,Polygon:void 0,Distance:void 0,Inversion:void 0};for(let t in u)y[t]=u[t];Object.defineProperty(y,"DP_TOL",{get:function(){return g()},set:function(t){d(t)}});class w{static get ILLEGAL_PARAMETERS(){return new ReferenceError("Illegal Parameters")}static get ZERO_DIVISION(){return new Error("Zero division")}static get UNRESOLVED_BOUNDARY_CONFLICT(){return new Error("Unresolved boundary conflict in boolean operation")}static get INFINITE_LOOP(){return new Error("Infinite loop")}static get CANNOT_COMPLETE_BOOLEAN_OPERATION(){return new Error("Cannot complete boolean operation")}static get CANNOT_INVOKE_ABSTRACT_METHOD(){return new Error("Abstract method cannot be invoked")}static get OPERATION_IS_NOT_SUPPORTED(){return new Error("Operation is not supported")}static get UNSUPPORTED_SHAPE_TYPE(){return new Error("Unsupported shape type")}}y.Errors=w;class I{constructor(t,e){this.first=t,this.last=e||this.first}[Symbol.iterator](){let t;return{next:()=>(t=t?t.next:this.first,{value:t,done:void 0===t})}}get size(){let t=0;for(let e of this)t++;return t}toArray(t=void 0,e=void 0){let n=[],i=t||this.first,r=e||this.last,s=i;if(void 0===s)return n;do{n.push(s),s=s.next}while(s!==r.next);return n}append(t){return this.isEmpty()?this.first=t:(t.prev=this.last,this.last.next=t),this.last=t,this.last.next=void 0,this.first.prev=void 0,this}insert(t,e){if(this.isEmpty())this.first=t,this.last=t;else if(null==e)t.next=this.first,this.first.prev=t,this.first=t;else{let n=e.next;e.next=t,n&&(n.prev=t),t.prev=e,t.next=n,this.last===e&&(this.last=t)}return this.last.next=void 0,this.first.prev=void 0,this}remove(t){return t===this.first&&t===this.last?(this.first=void 0,this.last=void 0):(t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t===this.first&&(this.first=t.next),t===this.last&&(this.last=t.prev)),this}isEmpty(){return void 0===this.first}static testInfiniteLoop(t){let e=t,n=t;do{if(e!=t&&e===n)throw w.INFINITE_LOOP;e=e.next,n=n.next.next}while(e!=t)}}const b={stroke:"black"};class T{constructor(t=b){for(const e in t)this[e]=t[e];this.stroke=t.stroke??b.stroke}toAttributesString(){return Object.keys(this).reduce(((t,e)=>t+(void 0!==this[e]?this.toAttrString(e,this[e]):"")),"")}toAttrString(t,e){const n="className"===t?"class":this.convertCamelToKebabCase(t);return null===e?`${n} `:`${n}="${e.toString()}" `}convertCamelToKebabCase(t){return t.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).join("-").toLowerCase()}}function P(t){return new T(t).toAttributesString()}function A(t,e){let n=[],[i,r,s]=t.standard,[o,a,l]=e.standard,h=i*a-r*o,c=s*a-r*l,f=i*l-s*o;if(!y.Utils.EQ_0(h)){let t,e;0===r?(t=s/i,e=f/h):0===a?(t=l/o,e=f/h):0===i?(t=c/h,e=s/r):0===o?(t=c/h,e=l/a):(t=c/h,e=f/h),n.push(new y.Point(t,e))}return n}function S(t,e){let n=[],i=e.pc.projectionOn(t),r=e.pc.distanceTo(i)[0];if(y.Utils.EQ(r,e.r))n.push(i);else if(y.Utils.LT(r,e.r)){let s,o,a=Math.sqrt(e.r*e.r-r*r);s=t.norm.rotate90CCW().multiply(a),o=i.translate(s),n.push(o),s=t.norm.rotate90CW().multiply(a),o=i.translate(s),n.push(o)}return n}function N(t,e){let n=[];for(let i of e.toSegments()){let e=L(i,t);for(let t of e)H(t,n)||n.push(t)}return n}function O(t,e){let n=[];if(0===N(t,e.box).length)return n;let i=S(t,new y.Circle(e.pc,e.r));for(let t of i)t.on(e)&&n.push(t);return n}function L(t,e){let n=[];return t.ps.on(e)&&n.push(t.ps),t.pe.on(e)&&!t.isZeroLength()&&n.push(t.pe),n.length>0||t.isZeroLength()||t.ps.leftTo(e)&&t.pe.leftTo(e)||!t.ps.leftTo(e)&&!t.pe.leftTo(e)?n:A(new y.Line(t.ps,t.pe),e)}function C(t,e){let n=[];if(t.box.not_intersect(e.box))return n;if(t.isZeroLength())return t.ps.on(e)&&n.push(t.ps),n;if(e.isZeroLength())return e.ps.on(t)&&n.push(e.ps),n;let i=new y.Line(t.ps,t.pe),r=new y.Line(e.ps,e.pe);if(i.incidentTo(r))t.ps.on(e)&&n.push(t.ps),t.pe.on(e)&&n.push(t.pe),!e.ps.on(t)||e.ps.equalTo(t.ps)||e.ps.equalTo(t.pe)||n.push(e.ps),!e.pe.on(t)||e.pe.equalTo(t.ps)||e.pe.equalTo(t.pe)||n.push(e.pe);else{let s=A(i,r);s.length>0&&U(s[0],t)&&U(s[0],e)&&n.push(s[0])}return n}function U(t,e){const n=e.box;return y.Utils.LE(t.x,n.xmax)&&y.Utils.GE(t.x,n.xmin)&&y.Utils.LE(t.y,n.ymax)&&y.Utils.GE(t.y,n.ymin)}function M(t,e){let n=[];if(t.box.not_intersect(e.box))return n;if(t.isZeroLength()){let[i,r]=t.ps.distanceTo(e.pc);return y.Utils.EQ(i,e.r)&&n.push(t.ps),n}let i=S(new y.Line(t.ps,t.pe),e);for(let e of i)e.on(t)&&n.push(e);return n}function R(t,e){let n=[];if(t.box.not_intersect(e.box))return n;if(t.isZeroLength())return t.ps.on(e)&&n.push(t.ps),n;let i=S(new y.Line(t.ps,t.pe),new y.Circle(e.pc,e.r));for(let r of i)r.on(t)&&r.on(e)&&n.push(r);return n}function k(t,e){let n=[];if(t.box.not_intersect(e.box))return n;let i=new y.Vector(t.pc,e.pc),r=t.r,s=e.r;if(y.Utils.EQ_0(r)||y.Utils.EQ_0(s))return n;if(y.Utils.EQ_0(i.x)&&y.Utils.EQ_0(i.y)&&y.Utils.EQ(r,s))return n.push(t.pc.translate(-r,0)),n;let o,a=t.pc.distanceTo(e.pc)[0];if(y.Utils.GT(a,r+s))return n;if(y.Utils.LT(a,Math.abs(r-s)))return n;if(i.x/=a,i.y/=a,y.Utils.EQ(a,r+s)||y.Utils.EQ(a,Math.abs(r-s)))return o=t.pc.translate(r*i.x,r*i.y),n.push(o),n;let l=r*r/(2*a)-s*s/(2*a)+a/2,h=t.pc.translate(l*i.x,l*i.y),c=Math.sqrt(r*r-l*l);return o=h.translate(i.rotate90CCW().multiply(c)),n.push(o),o=h.translate(i.rotate90CW().multiply(c)),n.push(o),n}function D(t,e){let n=[];if(t.box.not_intersect(e.box))return n;if(t.pc.equalTo(e.pc)&&y.Utils.EQ(t.r,e.r)){let i;return i=t.start,i.on(e)&&n.push(i),i=t.end,i.on(e)&&n.push(i),i=e.start,i.on(t)&&n.push(i),i=e.end,i.on(t)&&n.push(i),n}let i=new y.Circle(t.pc,t.r),r=new y.Circle(e.pc,e.r),s=i.intersect(r);for(let i of s)i.on(t)&&i.on(e)&&n.push(i);return n}function B(t,e){let n=[];if(t.box.not_intersect(e.box))return n;if(e.pc.equalTo(t.pc)&&y.Utils.EQ(e.r,t.r))return n.push(t.start),n.push(t.end),n;let i=k(e,new y.Circle(t.pc,t.r));for(let e of i)e.on(t)&&n.push(e);return n}function V(t,e){return t.isSegment?C(t.shape,e):R(e,t.shape)}function F(t,e){return t.isSegment?R(t.shape,e):D(t.shape,e)}function q(t,e){return t.isSegment?L(t.shape,e):O(e,t.shape)}function $(t,e){return t.isSegment?M(t.shape,e):B(t.shape,e)}function G(t,e){let n=[];for(let i of e.edges)for(let e of V(i,t))n.push(e);return n}function Y(t,e){let n=[];for(let i of e.edges)for(let e of F(i,t))n.push(e);return n}function Q(t,e){let n=[];if(e.isEmpty())return n;for(let i of e.edges)for(let e of q(i,t))H(e,n)||n.push(e);return t.sortPoints(n)}function W(t,e){let n=[];if(e.isEmpty())return n;for(let i of e.edges)for(let e of $(i,t))n.push(e);return n}function z(t,e){return t.isSegment?V(e,t.shape):t.isArc?F(e,t.shape):t.isLine?q(e,t.shape):t.isRay?function(t,e){return t.isSegment?J(e,t.shape):K(e,t.shape)}(e,t.shape):[]}function j(t,e){let n=[];if(e.isEmpty()||t.shape.box.not_intersect(e.box))return n;let i=e.edges.search(t.shape.box);for(let e of i)n=[...n,...z(t,e)];return n}function H(t,e){return e.some((e=>e.equalTo(t)))}function Z(t){return new y.Line(t.start,t.norm)}function J(t,e){return L(e,Z(t)).filter((e=>t.contains(e)))}function K(t,e){return O(Z(t),e).filter((e=>t.contains(e)))}function X(t,e){return S(Z(t),e).filter((e=>t.contains(e)))}function tt(t,e){return A(Z(t),e).filter((e=>t.contains(e)))}function et(t,e){return Q(Z(t),e).filter((e=>t.contains(e)))}function nt(t,e){if(t.intersect&&t.intersect instanceof Function)return t.intersect(e);throw w.UNSUPPORTED_SHAPE_TYPE}function it(t,e){let n=[];for(let i of e)n=[...n,...nt(t,i.shape)];return n}let rt=class t extends I{constructor(...t){if(super(),this.isInfinite=!1,1===t.length&&t[0]instanceof Array&&t[0].length>0){let e=!1;const n=t[0],i=n.length,r=t=>t instanceof y.Segment||t instanceof y.Arc||t instanceof y.Ray,s=t=>t instanceof y.Segment||t instanceof y.Arc;if(e=1===i&&(t=>t instanceof y.Segment||t instanceof y.Arc||t instanceof y.Ray||t instanceof y.Line)(n[0])||i>1&&r(n[0])&&r(n[i-1])&&n.slice(1,i-1).every(s),!e)throw y.Errors.ILLEGAL_PARAMETERS;this.isInfinite=n.some((t=>t instanceof y.Ray||t instanceof y.Line));for(let t of n){let e=new y.Edge(t);this.append(e)}this.setArcLength()}}get edges(){return[...this]}get box(){return this.edges.reduce(((t,e)=>t.merge(e.box)),new y.Box)}get vertices(){let t=this.edges.map((t=>t.start));return t.push(this.last.end),t}get length(){if(this.isEmpty())return 0;if(this.isInfinite)return Number.POSITIVE_INFINITY;let t=0;for(let e of this)t+=e.length;return t}clone(){return new t(this.toShapes())}setArcLength(){for(let t of this)this.setOneEdgeArcLength(t)}setOneEdgeArcLength(t){t===this.first?t.arc_length=0:t.arc_length=t.prev.arc_length+t.prev.length}pointAtLength(t){if(t>this.length||t<0)return null;if(this.isInfinite)return null;let e=null;for(let n of this)if(t>=n.arc_length&&(n===this.last||t<n.next.arc_length)){e=n.pointAtLength(t-n.arc_length);break}return e}addVertex(t,e){let n=e.shape.split(t);if(null===n[0])return e.prev;if(null===n[1])return e;let i=new y.Edge(n[0]),r=e.prev;return this.insert(i,r),e.shape=n[1],i}getChain(t,e){let n=[];for(let i=t;i!==e.next;i=i.next)n.push(i);return n}split(t){for(let e of t){let t=this.findEdgeByPoint(e);this.addVertex(e,t)}return this}findEdgeByPoint(t){let e;for(let n of this)if(n.shape.contains(t)){e=n;break}return e}distanceTo(t){if(t instanceof Point){const[e,n]=y.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof y.Line){const[e,n]=y.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof y.Circle){const[e,n]=y.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof y.Segment){const[e,n]=y.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof y.Arc){const[e,n]=y.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof y.Multiline)return y.Distance.multiline2multiline(this,t);throw y.Errors.UNSUPPORTED_SHAPE_TYPE}intersect(t){return t instanceof y.Multiline?function(t,e){let n=[];for(let i of t)for(let t of e)n=[...n,...nt(i,t)];return n}(this,t):it(t,this)}contains(t){if(t instanceof y.Point)return this.edges.some((e=>e.shape.contains(t)));throw y.Errors.UNSUPPORTED_SHAPE_TYPE}translate(e){return new t(this.edges.map((t=>t.shape.translate(e))))}rotate(e=0,n=new y.Point){return new t(this.edges.map((t=>t.shape.rotate(e,n))))}transform(e=new y.Matrix){return new t(this.edges.map((t=>t.shape.transform(e))))}toShapes(){return this.edges.map((t=>t.shape.clone()))}toJSON(){return this.edges.map((t=>t.toJSON()))}svgPoints(){return this.vertices.map((t=>`${t.x},${t.y}`)).join(" ")}dpath(){let t=`M${this.first.start.x},${this.first.start.y}`;for(let e of this)t+=e.svg();return t}svg(t={}){let e=`\n<path ${P({fill:"none",...t})} d="`;e+=`\nM${this.first.start.x},${this.first.start.y}`;for(let t of this)e+=t.svg();return e+='" >\n</path>',e}};y.Multiline=rt;const st=(...t)=>new y.Multiline(...t);function ot(t,e,n){let i=n.length,r=t.shape.split(e);if(0===r.length)return;let s=0;s=null===r[0]?0:null===r[1]?t.shape.length:r[0].length;let o,a=h;_(s,0)&&(a|=c),_(s,t.shape.length)&&(a|=f),o=s===1/0?r[0].coord(e):a&f&&t.next&&0===t.next.arc_length?0:t.arc_length+s,n.push({id:i,pt:e,arc_length:o,edge_before:t,edge_after:void 0,face:t.face,is_vertex:a})}function at(t){t.int_points1_sorted=lt(t.int_points1),t.int_points2_sorted=lt(t.int_points2)}function lt(t){let e=new Map,n=0;for(let i of t)e.has(i.face)||(e.set(i.face,n),n++);for(let n of t)n.faceId=e.get(n.face);return t.slice().sort(ht)}function ht(t,e){return t.faceId<e.faceId?-1:t.faceId>e.faceId?1:t.arc_length<e.arc_length?-1:t.arc_length>e.arc_length?1:0}function ct(t){if(t.int_points1.length<2)return;let e,n,i,r,s=!1;for(let o=0;o<t.int_points1_sorted.length;o++)if(-1!==t.int_points1_sorted[o].id){e=t.int_points1_sorted[o],n=t.int_points2[e.id];for(let a=o+1;a<t.int_points1_sorted.length&&(i=t.int_points1_sorted[a],_(i.arc_length,e.arc_length));a++)-1!==i.id&&(r=t.int_points2[i.id],-1!==r.id&&i.edge_before===e.edge_before&&i.edge_after===e.edge_after&&r.edge_before===n.edge_before&&r.edge_after===n.edge_after&&(i.id=-1,r.id=-1,s=!0))}n=t.int_points2_sorted[0],e=t.int_points1[n.id];for(let i=1;i<t.int_points2_sorted.length;i++){let r=t.int_points2_sorted[i];if(-1===r.id)continue;if(-1===n.id||!_(r.arc_length,n.arc_length)){n=r,e=t.int_points1[n.id];continue}let o=t.int_points1[r.id];o.edge_before===e.edge_before&&o.edge_after===e.edge_after&&r.edge_before===n.edge_before&&r.edge_after===n.edge_after&&(o.id=-1,r.id=-1,s=!0)}s&&(t.int_points1=t.int_points1.filter((t=>t.id>=0)),t.int_points2=t.int_points2.filter((t=>t.id>=0)),t.int_points1.forEach(((t,e)=>t.id=e)),t.int_points2.forEach(((t,e)=>t.id=e)))}function ft(t){for(let e of t)e.edge_before&&(e.edge_before.bvStart=void 0,e.edge_before.bvEnd=void 0,e.edge_before.bv=void 0,e.edge_before.overlap=void 0),e.edge_after&&(e.edge_after.bvStart=void 0,e.edge_after.bvEnd=void 0,e.edge_after.bv=void 0,e.edge_after.overlap=void 0);for(let e of t)e.edge_before&&(e.edge_before.bvEnd=o),e.edge_after&&(e.edge_after.bvStart=o)}function ut(t,e){for(let n of t)n.edge_before&&n.edge_before.setInclusion(e),n.edge_after&&n.edge_after.setInclusion(e)}function pt(t){let e,n,i,r=t.int_points1.length;for(let s=0;s<r;s++){let a=t.int_points1_sorted[s];a.face!==e&&(n=s,e=a.face);let l,h=s,c=dt(t.int_points1_sorted,s,e);l=h+c<r&&t.int_points1_sorted[h+c].face===e?h+c:n;let f=dt(t.int_points1_sorted,l,e);i=null;for(let n=l;n<l+f;n++){let r=t.int_points1_sorted[n];if(r.face===e&&t.int_points2[r.id].face===t.int_points2[a.id].face){i=r;break}}if(null===i)continue;let u=a.edge_after,p=i.edge_before;if(u.bv!==o||p.bv!==o)continue;if(u!==p)continue;let d=t.int_points2[a.id],g=t.int_points2[i.id],m=d.edge_after,_=g.edge_before;m.bv===o&&_.bv===o&&m===_||(d=t.int_points2[i.id],g=t.int_points2[a.id],m=d.edge_after,_=g.edge_before),m.bv===o&&_.bv===o&&m===_&&u.setOverlap(m)}}function dt(t,e,n){let i,r,s=1;if(1===t.length)return 1;i=t[e];for(let o=e+1;o<t.length&&i.face===n&&(r=t[o],r.pt.equalTo(i.pt)&&r.edge_before===i.edge_before&&r.edge_after===i.edge_after);o++)s++;return s}function gt(t,e){if(e){for(let n of e){let e=n.edge_before;if(n.is_vertex=h,e.shape.start&&e.shape.start.equalTo(n.pt)&&(n.is_vertex|=c),e.shape.end&&e.shape.end.equalTo(n.pt)&&(n.is_vertex|=f),n.is_vertex&c){n.edge_before=e.prev,e.prev&&(n.is_vertex=f);continue}if(n.is_vertex&f)continue;let i=t.addVertex(n.pt,e);n.edge_before=i}for(let n of e)n.edge_before?n.edge_after=n.edge_before.next:t instanceof rt&&n.is_vertex&c&&(n.edge_after=t.first)}}function mt(t,e,n){const i=t.edge_before,r=e.edge_after,s=n.length;i.next=n[0],n[0].prev=i,n[s-1].next=r,r.prev=n[s-1]}y.multiline=st;var _t=Object.freeze({__proto__:null,addToIntPoints:ot,calculateInclusionFlags:ut,filterDuplicatedIntersections:ct,getSortedArray:lt,initializeInclusionFlags:ft,insertBetweenIntPoints:mt,intPointsPoolCount:dt,setOverlappingFlags:pt,sortIntersections:at,splitByIntersections:gt});const{INSIDE:xt,OUTSIDE:vt,BOUNDARY:Et,OVERLAP_SAME:yt,OVERLAP_OPPOSITE:wt}=u,{NOT_VERTEX:It,START_VERTEX:bt,END_VERTEX:Tt}=u,Pt=1,At=2,St=3;function Nt(t,e){let n=e.clone().reverse(),[i,r]=Rt(t,n,St,!0);return i}function Ot(t,e){let[n,i]=Rt(t,e,At,!0);return n}function Lt(t,e){let[n,i]=Rt(t,e,At,!1),r=[];for(let t of n.faces)r=[...r,...[...t.edges].map((t=>t.shape))];let s=[];for(let t of i.faces)s=[...s,...[...t.edges].map((t=>t.shape))];return[r,s]}function Ct(t,e){let[n,i]=Rt(t,e,St,!1),r=[];for(let t of n.faces)r=[...r,...[...t.edges].map((t=>t.shape))];return r}function Ut(t,e){let n=t.clone(),i=e.clone(),r=kt(n,i);return at(r),gt(n,r.int_points1_sorted),gt(i,r.int_points2_sorted),ct(r),at(r),[r.int_points1_sorted.map((t=>t.pt)),r.int_points2_sorted.map((t=>t.pt))]}function Mt(t,e,n,i){!function(t,e,n,i){for(let n of e.faces){for(let e of n)t.edges.add(e);void 0===i.find((t=>t.face===n))&&t.addFace(n.first,n.last)}}(t,e,0,n.int_points2),function(t,e,n){if(0===n.int_points1.length)return;for(let t=0;t<n.int_points1.length;t++){let e=n.int_points1[t],i=n.int_points2[t];if(void 0!==e.edge_before&&void 0===e.edge_after&&void 0===i.edge_before&&void 0!==i.edge_after&&(e.edge_before.next=i.edge_after,i.edge_after.prev=e.edge_before,e.edge_after=i.edge_after,i.edge_before=e.edge_before),void 0!==i.edge_before&&void 0===i.edge_after&&void 0===e.edge_before&&void 0!==e.edge_after&&(i.edge_before.next=e.edge_after,e.edge_after.prev=i.edge_before,i.edge_after=e.edge_after,e.edge_before=i.edge_before),void 0!==e.edge_before&&void 0===e.edge_after)for(let t of n.int_points1_sorted)t!==e&&void 0===t.edge_before&&void 0!==t.edge_after&&t.pt.equalTo(e.pt)&&(e.edge_before.next=t.edge_after,t.edge_after.prev=e.edge_before,e.edge_after=t.edge_after,t.edge_before=e.edge_before);if(void 0!==i.edge_before&&void 0===i.edge_after)for(let t of n.int_points2_sorted)t!==i&&void 0===t.edge_before&&void 0!==t.edge_after&&t.pt.equalTo(i.pt)&&(i.edge_before.next=t.edge_after,t.edge_after.prev=i.edge_before,i.edge_after=t.edge_after,t.edge_before=i.edge_before)}}(0,0,n),qt(t,n.int_points1),qt(e,n.int_points2),$t(t,n.int_points1,n.int_points2),$t(t,n.int_points2,n.int_points1)}function Rt(t,e,n,i){let r=t.clone(),s=e.clone(),o=kt(r,s);return at(o),gt(r,o.int_points1_sorted),gt(s,o.int_points2_sorted),ct(o),at(o),function(t,e,n,i){let r=Dt(t,n.int_points1),s=Dt(e,n.int_points2);for(Bt(r,e),Bt(s,t),ft(n.int_points1),ft(n.int_points2),ut(n.int_points1,e),ut(n.int_points2,t);Vt(t,e,n.int_points1,n.int_points1_sorted,n.int_points2,n););pt(n),Ft(t,i,n.int_points1_sorted,!0),Ft(e,i,n.int_points2_sorted,!1),Gt(t,r,i,!0),Gt(e,s,i,!1)}(r,s,o,n),i&&Mt(r,s,o),[r,s]}function kt(t,e){let n={int_points1:[],int_points2:[]};for(let i of t.edges){let t=e.edges.search(i.box);for(let e of t){let t=i.shape.intersect(e.shape);for(let r of t)ot(i,r,n.int_points1),ot(e,r,n.int_points2)}}return n}function Dt(t,e){let n=[];for(let i of t.faces)e.find((t=>t.face===i))||n.push(i);return n}function Bt(t,e){for(let n of t)n.first.bv=n.first.bvStart=n.first.bvEnd=void 0,n.first.setInclusion(e)}function Vt(t,e,n,i,r,s){let o,a,l,h=i.length,c=!1;for(let f=0;f<h;f++){let u=i[f];u.face!==o&&(a=f,o=u.face);let p,d=f,g=dt(i,f,o);p=d+g<h&&i[d+g].face===o?d+g:a;let m=dt(i,p,o);l=null;for(let t=p;t<p+m;t++){let e=i[t];if(e.face===o&&r[e.id].face===r[u.id].face){l=e;break}}if(null===l)continue;let _=u.edge_after,x=l.edge_before;if(_.bv!==Et||x.bv==Et)if(_.bv==Et||x.bv!==Et){if(_.bv===Et&&x.bv===Et&&_!=x||_.bv===xt&&x.bv===vt||_.bv===vt&&x.bv===xt){let t=_.next;for(;t!=x;)t.bvStart=void 0,t.bvEnd=void 0,t.bv=void 0,t.setInclusion(e),t=t.next}if(_.bv!==Et||x.bv!==Et||_==x){if(_.bv===xt&&x.bv===vt||_.bv===vt&&x.bv===xt){let i=_;for(;i!=x;){if(i.bvStart===_.bv&&i.bvEnd===x.bv){let[o,a]=i.shape.distanceTo(e);if(o<10*y.DP_TOL){ot(i,a.ps,n);let o=n[n.length-1];if(o.is_vertex&bt)o.edge_after=i,o.edge_before=i.prev,i.bvStart=Et,i.bv=void 0,i.setInclusion(e);else if(o.is_vertex&Tt)o.edge_after=i.next,i.bvEnd=Et,i.bv=void 0,i.setInclusion(e);else{let t=e.addVertex(o.pt,i);o.edge_before=t,o.edge_after=t.next,t.setInclusion(e),t.next.bvStart=Et,t.next.bvEnd=void 0,t.next.bv=void 0,t.next.setInclusion(e)}let l=e.findEdgeByPoint(a.pe);ot(l,a.pe,r);let h=r[r.length-1];if(h.is_vertex&bt)h.edge_after=l,h.edge_before=l.prev;else if(h.is_vertex&Tt)h.edge_after=l.next;else{let n=r.find((t=>t.edge_after===l)),i=e.addVertex(h.pt,l);h.edge_before=i,h.edge_after=i.next,n&&(n.edge_after=i),i.bvStart=void 0,i.bvEnd=Et,i.bv=void 0,i.setInclusion(t),i.next.bvStart=Et,i.next.bvEnd=void 0,i.next.bv=void 0,i.next.setInclusion(t)}at(s),c=!0;break}}i=i.next}if(c)break;throw w.UNRESOLVED_BOUNDARY_CONFLICT}}else{let t,e=_.next;for(;e!=x;){if(e.bv!=Et)if(void 0===t)t=e.bv;else if(e.bv!=t)throw w.UNRESOLVED_BOUNDARY_CONFLICT;e=e.next}null!=t&&(_.bv=t,x.bv=t)}}else x.bv=_.bv;else _.bv=x.bv}return c}function Ft(t,e,n,i){if(!n)return;let r,s,o,a;for(let l=0;l<n.length;l++){if(o=n[l],o.face!==r&&(s=l,r=o.face),r.isEmpty())continue;let h,c=l,f=dt(n,l,r);h=c+f<n.length&&n[c+f].face===o.face?c+f:s,a=n[h];let u=h,p=dt(n,u,r),d=o.edge_after,g=a.edge_before;if(d.bv===xt&&g.bv===xt&&e===Pt||d.bv===vt&&g.bv===vt&&e===At||(d.bv===vt||g.bv===vt)&&e===St&&!i||(d.bv===xt||g.bv===xt)&&e===St&&i||d.bv===Et&&g.bv===Et&&d.overlap&yt&&i||d.bv===Et&&g.bv===Et&&d.overlap&wt){t.removeChain(r,d,g);for(let t=c;t<c+f;t++)n[t].edge_after=void 0;for(let t=u;t<u+p;t++)n[t].edge_before=void 0}l+=f-1}}function qt(t,e){for(let n of e)t.faces.delete(n.face),n.face=void 0,n.edge_before&&(n.edge_before.face=void 0),n.edge_after&&(n.edge_after.face=void 0)}function $t(t,e,n){for(let i of e){if(void 0===i.edge_before||void 0===i.edge_after)continue;if(i.face)continue;if(i.edge_after.face||i.edge_before.face)continue;let r=i.edge_after,s=i.edge_before;try{I.testInfiniteLoop(r)}catch(t){throw w.CANNOT_COMPLETE_BOOLEAN_OPERATION}let o=t.addFace(r,s);for(let t of e)t.edge_before&&t.edge_after&&t.edge_before.face===o&&t.edge_after.face===o&&(t.face=o);for(let t of n)t.edge_before&&t.edge_after&&t.edge_before.face===o&&t.edge_after.face===o&&(t.face=o)}}function Gt(t,e,n,i){for(let r of e){let e=r.first.bv;(n===Pt&&e===xt||n===St&&e===xt&&i||n===St&&e===vt&&!i||n===At&&e===vt)&&t.deleteFace(r)}}var Yt=Object.freeze({__proto__:null,BOOLEAN_INTERSECT:At,BOOLEAN_SUBTRACT:St,BOOLEAN_UNION:Pt,calculateIntersections:Ut,innerClip:Lt,intersect:Ot,outerClip:Ct,removeNotRelevantChains:Ft,removeOldFaces:qt,restoreFaces:$t,subtract:Nt,unify:function(t,e){let[n,i]=Rt(t,e,Pt,!0);return n}});const Qt=RegExp("T.F..FFF.|T.F...F.."),Wt=RegExp("T........|.T.......|...T.....|....T...."),zt=RegExp("FT.......|F..T.....|F...T...."),jt=RegExp("T.F..F..."),Ht=RegExp("T.F..F...|.TF..F...|..FT.F...|..F.TF...");class Zt{constructor(){this.m=new Array(9).fill(void 0)}get I2I(){return this.m[0]}set I2I(t){this.m[0]=t}get I2B(){return this.m[1]}set I2B(t){this.m[1]=t}get I2E(){return this.m[2]}set I2E(t){this.m[2]=t}get B2I(){return this.m[3]}set B2I(t){this.m[3]=t}get B2B(){return this.m[4]}set B2B(t){this.m[4]=t}get B2E(){return this.m[5]}set B2E(t){this.m[5]=t}get E2I(){return this.m[6]}set E2I(t){this.m[6]=t}get E2B(){return this.m[7]}set E2B(t){this.m[7]=t}get E2E(){return this.m[8]}set E2E(t){this.m[8]=t}toString(){return this.m.map((t=>t instanceof Array&&t.length>0?"T":t instanceof Array&&0===t.length?"F":"*")).join("")}equal(){return Qt.test(this.toString())}intersect(){return Wt.test(this.toString())}touch(){return zt.test(this.toString())}inside(){return jt.test(this.toString())}covered(){return Ht.test(this.toString())}}function Jt(t,e){let n,i=new y.Ray(e),o=new y.Line(i.pt,i.norm);const a=new y.Box(i.box.xmin-y.DP_TOL,i.box.ymin-y.DP_TOL,i.box.xmax,i.box.ymax+y.DP_TOL);if(t.box.not_intersect(a))return y.OUTSIDE;let l=t.edges.search(a);if(0===l.length)return y.OUTSIDE;for(let t of l)if(t.shape.contains(e))return y.BOUNDARY;let h=[...t.faces],c=[];for(let t of l)for(let n of i.intersect(t.shape)){if(n.equalTo(e))return y.BOUNDARY;c.push({pt:n,edge:t,face_index:h.indexOf(t.face)})}c.sort(((t,e)=>v(t.pt.x,e.pt.x)?-1:x(t.pt.x,e.pt.x)?1:t.face_index<e.face_index?-1:t.face_index>e.face_index?1:t.edge.arc_length<e.edge.arc_length?-1:t.edge.arc_length>e.edge.arc_length?1:0));let f=0;for(let t=0;t<c.length;t++){let e=c[t];if(e.pt.equalTo(e.edge.shape.start)){if(t>0&&e.pt.equalTo(c[t-1].pt)&&e.face_index===c[t-1].face_index&&e.edge.prev===c[t-1].edge)continue;let n=e.edge.prev;for(;m(n.length);)n=n.prev;let i=n.shape.tangentInEnd(),r=e.pt.translate(i),s=e.edge.shape.tangentInStart(),a=e.pt.translate(s),l=r.leftTo(o),h=a.leftTo(o);(l&&!h||!l&&h)&&f++}else if(e.pt.equalTo(e.edge.shape.end)){if(t>0&&e.pt.equalTo(c[t-1].pt)&&e.face_index===c[t-1].face_index&&e.edge.next===c[t-1].edge)continue;let n=e.edge.next;for(;m(n.length);)n=n.next;let i=n.shape.tangentInStart(),r=e.pt.translate(i),s=e.edge.shape.tangentInEnd(),a=e.pt.translate(s),l=r.leftTo(o),h=a.leftTo(o);(l&&!h||!l&&h)&&f++}else if(e.edge.shape instanceof y.Segment)f++;else{let t=e.edge.shape.box;_(e.pt.y,t.ymin)||_(e.pt.y,t.ymax)||f++}}return n=f%2==1?r:s,n}function Kt(t,e){return ne(t,e).intersect()}function Xt(t,e){return ne(t,e).inside()}function te(t,e){return ne(t,e).covered()}function ee(t,e){return te(e,t)}function ne(t,e){return t instanceof y.Line&&e instanceof y.Line?function(t,e){let n=new Zt,i=A(t,e);0===i.length?t.contains(e.pt)&&e.contains(t.pt)?(n.I2I=[t],n.I2E=[],n.E2I=[]):(n.I2I=[],n.I2E=[t],n.E2I=[e]):(n.I2I=i,n.I2E=t.split(i),n.E2I=e.split(i));return n}(t,e):t instanceof y.Line&&e instanceof y.Circle?function(t,e){let n=new Zt,i=S(t,e);if(0===i.length)n.I2I=[],n.I2B=[],n.I2E=[t],n.E2I=[e];else if(1===i.length)n.I2I=[],n.I2B=i,n.I2E=t.split(i),n.E2I=[e];else{let r=new rt([t]),s=t.sortPoints(i);r.split(s);let o=r.toShapes();n.I2I=[o[1]],n.I2B=s,n.I2E=[o[0],o[2]],n.E2I=new y.Polygon([e.toArc()]).cutWithLine(t)}return n}(t,e):t instanceof y.Line&&e instanceof y.Box?function(t,e){let n=new Zt,i=N(t,e);if(0===i.length)n.I2I=[],n.I2B=[],n.I2E=[t],n.E2I=[e];else if(1===i.length)n.I2I=[],n.I2B=i,n.I2E=t.split(i),n.E2I=[e];else{let r=new rt([t]),s=t.sortPoints(i);r.split(s);let o=r.toShapes();e.toSegments().some((t=>t.contains(i[0])&&t.contains(i[1])))?(n.I2I=[],n.I2B=[o[1]],n.I2E=[o[0],o[2]],n.E2I=[e]):(n.I2I=[o[1]],n.I2B=s,n.I2E=[o[0],o[2]],n.E2I=new y.Polygon(e.toSegments()).cutWithLine(t))}return n}(t,e):t instanceof y.Line&&e instanceof y.Polygon?function(t,e){let n=new Zt,i=Q(t,e),r=new rt([t]),s=i.length>0?i.slice():t.sortPoints(i);return r.split(s),[...r].forEach((t=>t.setInclusion(e))),n.I2I=[...r].filter((t=>t.bv===y.INSIDE)).map((t=>t.shape)),n.I2B=[...r].slice(1).map((t=>t.bv===y.BOUNDARY?t.shape:t.shape.start)),n.I2E=[...r].filter((t=>t.bv===y.OUTSIDE)).map((t=>t.shape)),n.E2I=e.cutWithLine(t),n}(t,e):(t instanceof y.Segment||t instanceof y.Arc)&&e instanceof y.Polygon?ie(t,e):(t instanceof y.Segment||t instanceof y.Arc)&&(e instanceof y.Circle||e instanceof y.Box)?ie(t,new y.Polygon(e)):t instanceof y.Polygon&&e instanceof y.Polygon?re(t,e):(t instanceof y.Circle||t instanceof y.Box)&&(e instanceof y.Circle||e instanceof y.Box)?re(new y.Polygon(t),new y.Polygon(e)):(t instanceof y.Circle||t instanceof y.Box)&&e instanceof y.Polygon?re(new y.Polygon(t),e):t instanceof y.Polygon&&(e instanceof y.Circle||e instanceof y.Box)?re(t,new y.Polygon(e)):void 0}function ie(t,e){let n=new Zt,i=function(t,e){return t instanceof y.Line?Q(t,e):t instanceof y.Segment?G(t,e):t instanceof y.Arc?Y(t,e):[]}(t,e),r=i.length>0?i.slice():t.sortPoints(i),s=new rt([t]);s.split(r),[...s].forEach((t=>t.setInclusion(e))),n.I2I=[...s].filter((t=>t.bv===y.INSIDE)).map((t=>t.shape)),n.I2B=[...s].slice(1).map((t=>t.bv===y.BOUNDARY?t.shape:t.shape.start)),n.I2E=[...s].filter((t=>t.bv===y.OUTSIDE)).map((t=>t.shape)),n.B2I=[],n.B2B=[],n.B2E=[];for(let i of[t.start,t.end])switch(Jt(e,i)){case y.INSIDE:n.B2I.push(i);break;case y.BOUNDARY:n.B2B.push(i);break;case y.OUTSIDE:n.B2E.push(i)}return n}function re(t,e){let n=new Zt,[i,r]=Ut(t,e),s=Ot(t,e),o=Nt(t,e),a=Nt(e,t),[l,h]=Lt(t,e),c=Ct(t,e),f=Ct(e,t);return n.I2I=s.isEmpty()?[]:[s],n.I2B=h,n.I2E=o.isEmpty()?[]:[o],n.B2I=l,n.B2B=i,n.B2E=c,n.E2I=a.isEmpty()?[]:[a],n.E2B=f,n}var se=Object.freeze({__proto__:null,contain:function(t,e){return Xt(e,t)},cover:ee,covered:te,disjoint:function(t,e){return!Kt(t,e)},equal:function(t,e){return ne(t,e).equal()},inside:Xt,intersect:Kt,relate:ne,touch:function(t,e){return ne(t,e).touch()}});class oe{constructor(t=1,e=0,n=0,i=1,r=0,s=0){this.a=t,this.b=e,this.c=n,this.d=i,this.tx=r,this.ty=s}clone(){return new oe(this.a,this.b,this.c,this.d,this.tx,this.ty)}transform(t){return[t[0]*this.a+t[1]*this.c+this.tx,t[0]*this.b+t[1]*this.d+this.ty]}multiply(t){return new oe(this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.tx+this.c*t.ty+this.tx,this.b*t.tx+this.d*t.ty+this.ty)}translate(...t){let e,n;if(1!=t.length||isNaN(t[0].x)||isNaN(t[0].y)){if(2!==t.length||"number"!=typeof t[0]||"number"!=typeof t[1])throw w.ILLEGAL_PARAMETERS;e=t[0],n=t[1]}else e=t[0].x,n=t[0].y;return this.multiply(new oe(1,0,0,1,e,n))}rotate(t,e=0,n=0){let i=Math.cos(t),r=Math.sin(t);return this.translate(e,n).multiply(new oe(i,r,-r,i,0,0)).translate(-e,-n)}scale(t,e){return this.multiply(new oe(t,0,0,e,0,0))}equalTo(t){return!!y.Utils.EQ(this.tx,t.tx)&&(!!y.Utils.EQ(this.ty,t.ty)&&(!!y.Utils.EQ(this.a,t.a)&&(!!y.Utils.EQ(this.b,t.b)&&(!!y.Utils.EQ(this.c,t.c)&&!!y.Utils.EQ(this.d,t.d)))))}}y.Matrix=oe;const ae=(...t)=>new y.Matrix(...t);y.matrix=ae;class le{constructor(t=void 0,e=void 0,n=null,i=null,r=null,s=1){this.left=n,this.right=i,this.parent=r,this.color=s,this.item={key:t,value:e},t&&t instanceof Array&&2==t.length&&(Number.isNaN(t[0])||Number.isNaN(t[1])||(this.item.key=new class t{constructor(t,e){this.low=t,this.high=e}clone(){return new t(this.low,this.high)}get max(){return this.clone()}less_than(t){return this.low<t.low||this.low==t.low&&this.high<t.high}equal_to(t){return this.low==t.low&&this.high==t.high}intersect(t){return!this.not_intersect(t)}not_intersect(t){return this.high<t.low||t.high<this.low}merge(e){return new t(void 0===this.low?e.low:Math.min(this.low,e.low),void 0===this.high?e.high:Math.max(this.high,e.high))}output(){return[this.low,this.high]}static comparable_max(t,e){return t.merge(e)}static comparable_less_than(t,e){return t<e}}(Math.min(t[0],t[1]),Math.max(t[0],t[1])))),this.max=this.item.key?this.item.key.max:void 0}isNil(){return void 0===this.item.key&&void 0===this.item.value&&null===this.left&&null===this.right&&1===this.color}_value_less_than(t){return this.item.value&&t.item.value&&this.item.value.less_than?this.item.value.less_than(t.item.value):this.item.value<t.item.value}less_than(t){return this.item.value===this.item.key&&t.item.value===t.item.key?this.item.key.less_than(t.item.key):this.item.key.less_than(t.item.key)||this.item.key.equal_to(t.item.key)&&this._value_less_than(t)}_value_equal(t){return this.item.value&&t.item.value&&this.item.value.equal_to?this.item.value.equal_to(t.item.value):this.item.value==t.item.value}equal_to(t){return this.item.value===this.item.key&&t.item.value===t.item.key?this.item.key.equal_to(t.item.key):this.item.key.equal_to(t.item.key)&&this._value_equal(t)}intersect(t){return this.item.key.intersect(t.item.key)}copy_data(t){this.item.key=t.item.key,this.item.value=t.item.value}update_max(){if(this.max=this.item.key?this.item.key.max:void 0,this.right&&this.right.max){const t=this.item.key.constructor.comparable_max;this.max=t(this.max,this.right.max)}if(this.left&&this.left.max){const t=this.item.key.constructor.comparable_max;this.max=t(this.max,this.left.max)}}not_intersect_left_subtree(t){return(0,this.item.key.constructor.comparable_less_than)(void 0!==this.left.max.high?this.left.max.high:this.left.max,t.item.key.low)}not_intersect_right_subtree(t){const e=this.item.key.constructor.comparable_less_than;let n=void 0!==this.right.max.low?this.right.max.low:this.right.item.key.low;return e(t.item.key.high,n)}}class he{constructor(){this.root=null,this.nil_node=new le}get size(){let t=0;return this.tree_walk(this.root,(()=>t++)),t}get keys(){let t=[];return this.tree_walk(this.root,(e=>t.push(e.item.key.output?e.item.key.output():e.item.key))),t}get values(){let t=[];return this.tree_walk(this.root,(e=>t.push(e.item.value))),t}get items(){let t=[];return this.tree_walk(this.root,(e=>t.push({key:e.item.key.output?e.item.key.output():e.item.key,value:e.item.value}))),t}isEmpty(){return null==this.root||this.root==this.nil_node}clear(){this.root=null}insert(t,e=t){if(void 0===t)return;let n=new le(t,e,this.nil_node,this.nil_node,null,0);return this.tree_insert(n),this.recalc_max(n),n}exist(t,e=t){let n=new le(t,e);return!!this.tree_search(this.root,n)}remove(t,e=t){let n=new le(t,e),i=this.tree_search(this.root,n);return i&&this.tree_delete(i),i}search(t,e=((t,e)=>t===e?e.output():t)){let n=new le(t),i=[];return this.tree_search_interval(this.root,n,i),i.map((t=>e(t.item.value,t.item.key)))}intersect_any(t){let e=new le(t);return this.tree_find_any_interval(this.root,e)}forEach(t){this.tree_walk(this.root,(e=>t(e.item.key,e.item.value)))}map(t){const e=new he;return this.tree_walk(this.root,(n=>e.insert(n.item.key,t(n.item.value,n.item.key)))),e}recalc_max(t){let e=t;for(;null!=e.parent;)e.parent.update_max(),e=e.parent}tree_insert(t){let e=this.root,n=null;if(null==this.root||this.root==this.nil_node)this.root=t;else{for(;e!=this.nil_node;)n=e,e=t.less_than(e)?e.left:e.right;t.parent=n,t.less_than(n)?n.left=t:n.right=t}this.insert_fixup(t)}insert_fixup(t){let e,n;for(e=t;e!=this.root&&0==e.parent.color;)e.parent==e.parent.parent.left?(n=e.parent.parent.right,0==n.color?(e.parent.color=1,n.color=1,e.parent.parent.color=0,e=e.parent.parent):(e==e.parent.right&&(e=e.parent,this.rotate_left(e)),e.parent.color=1,e.parent.parent.color=0,this.rotate_right(e.parent.parent))):(n=e.parent.parent.left,0==n.color?(e.parent.color=1,n.color=1,e.parent.parent.color=0,e=e.parent.parent):(e==e.parent.left&&(e=e.parent,this.rotate_right(e)),e.parent.color=1,e.parent.parent.color=0,this.rotate_left(e.parent.parent)));this.root.color=1}tree_delete(t){let e,n;e=t.left==this.nil_node||t.right==this.nil_node?t:this.tree_successor(t),n=e.left!=this.nil_node?e.left:e.right,n.parent=e.parent,e==this.root?this.root=n:(e==e.parent.left?e.parent.left=n:e.parent.right=n,e.parent.update_max()),this.recalc_max(n),e!=t&&(t.copy_data(e),t.update_max(),this.recalc_max(t)),1==e.color&&this.delete_fixup(n)}delete_fixup(t){let e,n=t;for(;n!=this.root&&null!=n.parent&&1==n.color;)n==n.parent.left?(e=n.parent.right,0==e.color&&(e.color=1,n.parent.color=0,this.rotate_left(n.parent),e=n.parent.right),1==e.left.color&&1==e.right.color?(e.color=0,n=n.parent):(1==e.right.color&&(e.color=0,e.left.color=1,this.rotate_right(e),e=n.parent.right),e.color=n.parent.color,n.parent.color=1,e.right.color=1,this.rotate_left(n.parent),n=this.root)):(e=n.parent.left,0==e.color&&(e.color=1,n.parent.color=0,this.rotate_right(n.parent),e=n.parent.left),1==e.left.color&&1==e.right.color?(e.color=0,n=n.parent):(1==e.left.color&&(e.color=0,e.right.color=1,this.rotate_left(e),e=n.parent.left),e.color=n.parent.color,n.parent.color=1,e.left.color=1,this.rotate_right(n.parent),n=this.root));n.color=1}tree_search(t,e){if(null!=t&&t!=this.nil_node)return e.equal_to(t)?t:e.less_than(t)?this.tree_search(t.left,e):this.tree_search(t.right,e)}tree_search_interval(t,e,n){null!=t&&t!=this.nil_node&&(t.left==this.nil_node||t.not_intersect_left_subtree(e)||this.tree_search_interval(t.left,e,n),t.intersect(e)&&n.push(t),t.right==this.nil_node||t.not_intersect_right_subtree(e)||this.tree_search_interval(t.right,e,n))}tree_find_any_interval(t,e){let n=!1;return null!=t&&t!=this.nil_node&&(t.left==this.nil_node||t.not_intersect_left_subtree(e)||(n=this.tree_find_any_interval(t.left,e)),n||(n=t.intersect(e)),n||t.right==this.nil_node||t.not_intersect_right_subtree(e)||(n=this.tree_find_any_interval(t.right,e))),n}local_minimum(t){let e=t;for(;null!=e.left&&e.left!=this.nil_node;)e=e.left;return e}local_maximum(t){let e=t;for(;null!=e.right&&e.right!=this.nil_node;)e=e.right;return e}tree_successor(t){let e,n,i;if(t.right!=this.nil_node)e=this.local_minimum(t.right);else{for(n=t,i=t.parent;null!=i&&i.right==n;)n=i,i=i.parent;e=i}return e}rotate_left(t){let e=t.right;t.right=e.left,e.left!=this.nil_node&&(e.left.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e,null!=t&&t!=this.nil_node&&t.update_max(),e=t.parent,null!=e&&e!=this.nil_node&&e.update_max()}rotate_right(t){let e=t.left;t.left=e.right,e.right!=this.nil_node&&(e.right.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.right=t,t.parent=e,null!=t&&t!=this.nil_node&&t.update_max(),e=t.parent,null!=e&&e!=this.nil_node&&e.update_max()}tree_walk(t,e){null!=t&&t!=this.nil_node&&(this.tree_walk(t.left,e),e(t),this.tree_walk(t.right,e))}testRedBlackProperty(){let t=!0;return this.tree_walk(this.root,(function(e){0==e.color&&(1==e.left.color&&1==e.right.color||(t=!1))})),t}testBlackHeightProperty(t){let e=0,n=0,i=0;if(1==t.color&&e++,n=t.left!=this.nil_node?this.testBlackHeightProperty(t.left):1,i=t.right!=this.nil_node?this.testBlackHeightProperty(t.right):1,n!=i)throw new Error("Red-black height property violated");return e+=n,e}}class ce extends Set{constructor(t){super(t),this.index=new he,this.forEach((t=>this.index.insert(t)))}add(t){let e=this.size;const{key:n,value:i}=t,r=n||t.box,s=i||t;return super.add(s),this.size>e&&this.index.insert(r,s),this}delete(t){const{key:e,value:n}=t,i=e||t.box,r=n||t;let s=super.delete(r);return s&&this.index.remove(i,r),s}clear(){super.clear(),this.index=new he}search(t){return this.index.search(t)}hit(t){let e=new y.Box(t.x-1,t.y-1,t.x+1,t.y+1);return this.index.search(e).filter((e=>t.on(e)))}svg(){return[...this].reduce(((t,e)=>t+e.svg()),"")}}y.PlanarSet=ce;class fe{get name(){throw w.CANNOT_INVOKE_ABSTRACT_METHOD}get box(){throw w.CANNOT_INVOKE_ABSTRACT_METHOD}clone(){throw w.CANNOT_INVOKE_ABSTRACT_METHOD}translate(...t){return this.transform((new oe).translate(...t))}rotate(t,e=new y.Point){return this.transform((new oe).rotate(t,e.x,e.y))}scale(t,e){return this.transform((new oe).scale(t,e))}transform(...t){throw w.CANNOT_INVOKE_ABSTRACT_METHOD}toJSON(){return Object.assign({},this,{name:this.name})}svg(t={}){throw w.CANNOT_INVOKE_ABSTRACT_METHOD}}let ue=class t extends fe{constructor(...t){if(super(),this.x=0,this.y=0,0!==t.length){if(1===t.length&&t[0]instanceof Array&&2===t[0].length){let e=t[0];if("number"==typeof e[0]&&"number"==typeof e[1])return this.x=e[0],void(this.y=e[1])}if(1===t.length&&t[0]instanceof Object&&"point"===t[0].name){let{x:e,y:n}=t[0];return this.x=e,void(this.y=n)}if(2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])return this.x=t[0],void(this.y=t[1]);throw w.ILLEGAL_PARAMETERS}}get box(){return new y.Box(this.x,this.y,this.x,this.y)}clone(){return new y.Point(this.x,this.y)}get vertices(){return[this.clone()]}equalTo(t){return y.Utils.EQ(this.x,t.x)&&y.Utils.EQ(this.y,t.y)}lessThan(t){return!!y.Utils.LT(this.y,t.y)||!(!y.Utils.EQ(this.y,t.y)||!y.Utils.LT(this.x,t.x))}transform(t){return new y.Point(t.transform([this.x,this.y]))}projectionOn(t){if(this.equalTo(t.pt))return this.clone();let e=new y.Vector(this,t.pt);if(y.Utils.EQ_0(e.cross(t.norm)))return t.pt.clone();let n=e.dot(t.norm),i=t.norm.multiply(n);return this.translate(i)}leftTo(t){let e=new y.Vector(t.pt,this);return y.Utils.GT(e.dot(t.norm),0)}distanceTo(e){if(e instanceof t){let t=e.x-this.x,n=e.y-this.y;return[Math.sqrt(t*t+n*n),new y.Segment(this,e)]}return e instanceof y.Line?y.Distance.point2line(this,e):e instanceof y.Circle?y.Distance.point2circle(this,e):e instanceof y.Segment?y.Distance.point2segment(this,e):e instanceof y.Arc?y.Distance.point2arc(this,e):e instanceof y.Polygon?y.Distance.point2polygon(this,e):e instanceof y.PlanarSet?y.Distance.shape2planarSet(this,e):e instanceof y.Multiline?y.Distance.shape2multiline(this,e):void 0}on(t){if(t instanceof y.Point)return this.equalTo(t);if(t.contains&&t.contains instanceof Function)return t.contains(this);throw y.Errors.UNSUPPORTED_SHAPE_TYPE}get name(){return"point"}svg(t={}){const e=t.r??3;return`\n<circle cx="${this.x}" cy="${this.y}" r="${e}"\n            ${P({fill:"red",...t})} />`}};y.Point=ue;const pe=(...t)=>new y.Point(...t);y.point=pe;let de=class extends fe{constructor(...t){if(super(),this.x=0,this.y=0,0!==t.length){if(1===t.length&&t[0]instanceof Array&&2===t[0].length){let e=t[0];if("number"==typeof e[0]&&"number"==typeof e[1])return this.x=e[0],void(this.y=e[1])}if(1===t.length&&t[0]instanceof Object&&"vector"===t[0].name){let{x:e,y:n}=t[0];return this.x=e,void(this.y=n)}if(2===t.length){let e=t[0],n=t[1];if("number"==typeof e&&"number"==typeof n)return this.x=e,void(this.y=n);if(e instanceof y.Point&&n instanceof y.Point)return this.x=n.x-e.x,void(this.y=n.y-e.y)}throw w.ILLEGAL_PARAMETERS}}clone(){return new y.Vector(this.x,this.y)}get slope(){let t=Math.atan2(this.y,this.x);return t<0&&(t=2*Math.PI+t),t}get length(){return Math.sqrt(this.dot(this))}equalTo(t){return y.Utils.EQ(this.x,t.x)&&y.Utils.EQ(this.y,t.y)}multiply(t){return new y.Vector(t*this.x,t*this.y)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}normalize(){if(!y.Utils.EQ_0(this.length))return new y.Vector(this.x/this.length,this.y/this.length);throw w.ZERO_DIVISION}rotate(t,e=new y.Point){if(0===e.x&&0===e.y)return this.transform((new oe).rotate(t));throw w.OPERATION_IS_NOT_SUPPORTED}transform(t){return new y.Vector(t.transform([this.x,this.y]))}rotate90CCW(){return new y.Vector(-this.y,this.x)}rotate90CW(){return new y.Vector(this.y,-this.x)}invert(){return new y.Vector(-this.x,-this.y)}add(t){return new y.Vector(this.x+t.x,this.y+t.y)}subtract(t){return new y.Vector(this.x-t.x,this.y-t.y)}angleTo(t){let e=this.normalize(),n=t.normalize(),i=Math.atan2(e.cross(n),e.dot(n));return i<0&&(i+=2*Math.PI),i}projectionOn(t){let e=t.normalize(),n=this.dot(e);return e.multiply(n)}get name(){return"vector"}};y.Vector=de;const ge=(...t)=>new y.Vector(...t);y.vector=ge;let me=class t extends fe{constructor(...t){if(super(),this.ps=new y.Point,this.pe=new y.Point,0!==t.length){if(1===t.length&&t[0]instanceof Array&&4===t[0].length){let e=t[0];return this.ps=new y.Point(e[0],e[1]),void(this.pe=new y.Point(e[2],e[3]))}if(1===t.length&&t[0]instanceof Object&&"segment"===t[0].name){let{ps:e,pe:n}=t[0];return this.ps=new y.Point(e.x,e.y),void(this.pe=new y.Point(n.x,n.y))}if(!(1===t.length&&t[0]instanceof y.Point)){if(2===t.length&&t[0]instanceof y.Point&&t[1]instanceof y.Point)return this.ps=t[0].clone(),void(this.pe=t[1].clone());if(4===t.length)return this.ps=new y.Point(t[0],t[1]),void(this.pe=new y.Point(t[2],t[3]));throw w.ILLEGAL_PARAMETERS}this.ps=t[0].clone()}}clone(){return new y.Segment(this.start,this.end)}get start(){return this.ps}get end(){return this.pe}get vertices(){return[this.ps.clone(),this.pe.clone()]}get length(){return this.start.distanceTo(this.end)[0]}get slope(){return new y.Vector(this.start,this.end).slope}get box(){return new y.Box(Math.min(this.start.x,this.end.x),Math.min(this.start.y,this.end.y),Math.max(this.start.x,this.end.x),Math.max(this.start.y,this.end.y))}equalTo(t){return this.ps.equalTo(t.ps)&&this.pe.equalTo(t.pe)}contains(t){return y.Utils.EQ_0(this.distanceToPoint(t))}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Line?L(this,t):t instanceof y.Ray?J(t,this):t instanceof y.Segment?C(this,t):t instanceof y.Circle?M(this,t):t instanceof y.Box?function(t,e){let n=[];for(let i of e.toSegments()){let e=C(i,t);for(let t of e)n.push(t)}return n}(this,t):t instanceof y.Arc?R(this,t):t instanceof y.Polygon?G(this,t):t instanceof y.Multiline?it(this,t):void 0}distanceTo(t){if(t instanceof y.Point){let[e,n]=y.Distance.point2segment(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Circle){let[e,n]=y.Distance.segment2circle(this,t);return[e,n]}if(t instanceof y.Line){let[e,n]=y.Distance.segment2line(this,t);return[e,n]}if(t instanceof y.Segment){let[e,n]=y.Distance.segment2segment(this,t);return[e,n]}if(t instanceof y.Arc){let[e,n]=y.Distance.segment2arc(this,t);return[e,n]}if(t instanceof y.Polygon){let[e,n]=y.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof y.PlanarSet){let[e,n]=y.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof y.Multiline)return y.Distance.shape2multiline(this,t)}tangentInStart(){return new y.Vector(this.start,this.end).normalize()}tangentInEnd(){return new y.Vector(this.end,this.start).normalize()}reverse(){return new t(this.end,this.start)}split(t){return this.start.equalTo(t)?[null,this.clone()]:this.end.equalTo(t)?[this.clone(),null]:[new y.Segment(this.start,t),new y.Segment(t,this.end)]}middle(){return new y.Point((this.start.x+this.end.x)/2,(this.start.y+this.end.y)/2)}pointAtLength(t){if(t>this.length||t<0)return null;if(0==t)return this.start;if(t==this.length)return this.end;let e=t/this.length;return new y.Point((this.end.x-this.start.x)*e+this.start.x,(this.end.y-this.start.y)*e+this.start.y)}distanceToPoint(t){let[e,...n]=y.Distance.point2segment(t,this);return e}definiteIntegral(t=0){return(this.end.x-this.start.x)*(this.start.y-t+(this.end.y-t))/2}transform(e=new y.Matrix){return new t(this.ps.transform(e),this.pe.transform(e))}isZeroLength(){return this.ps.equalTo(this.pe)}sortPoints(t){return new y.Line(this.start,this.end).sortPoints(t)}get name(){return"segment"}svg(t={}){return`\n<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" ${P(t)} />`}};y.Segment=me;const _e=(...t)=>new y.Segment(...t);y.segment=_e;let{vector:xe}=y,ve=class t extends fe{constructor(...e){if(super(),this.pt=new y.Point,this.norm=new y.Vector(0,1),0!==e.length){if(1===e.length&&e[0]instanceof Object&&"line"===e[0].name){let{pt:t,norm:n}=e[0];return this.pt=new y.Point(t),void(this.norm=new y.Vector(n))}if(2===e.length){let n=e[0],i=e[1];if(n instanceof y.Point&&i instanceof y.Point)return this.pt=n,this.norm=t.points2norm(n,i),void(this.norm.dot(xe(this.pt.x,this.pt.y))>=0&&this.norm.invert());if(n instanceof y.Point&&i instanceof y.Vector){if(y.Utils.EQ_0(i.x)&&y.Utils.EQ_0(i.y))throw w.ILLEGAL_PARAMETERS;return this.pt=n.clone(),this.norm=i.clone(),this.norm=this.norm.normalize(),void(this.norm.dot(xe(this.pt.x,this.pt.y))>=0&&this.norm.invert())}if(n instanceof y.Vector&&i instanceof y.Point){if(y.Utils.EQ_0(n.x)&&y.Utils.EQ_0(n.y))throw w.ILLEGAL_PARAMETERS;return this.pt=i.clone(),this.norm=n.clone(),this.norm=this.norm.normalize(),void(this.norm.dot(xe(this.pt.x,this.pt.y))>=0&&this.norm.invert())}}throw w.ILLEGAL_PARAMETERS}}clone(){return new y.Line(this.pt,this.norm)}get start(){}get end(){}get length(){return Number.POSITIVE_INFINITY}get box(){return new y.Box(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}get middle(){}get slope(){return new y.Vector(this.norm.y,-this.norm.x).slope}get standard(){return[this.norm.x,this.norm.y,this.norm.dot(xe(this.pt.x,this.pt.y))]}parallelTo(t){return y.Utils.EQ_0(this.norm.cross(t.norm))}incidentTo(t){return this.parallelTo(t)&&this.pt.on(t)}contains(t){if(this.pt.equalTo(t))return!0;let e=new y.Vector(this.pt,t);return y.Utils.EQ_0(this.norm.dot(e))}coord(t){return xe(t.x,t.y).cross(this.norm)}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Line?A(this,t):t instanceof y.Ray?tt(t,this):t instanceof y.Circle?S(this,t):t instanceof y.Box?N(this,t):t instanceof y.Segment?L(t,this):t instanceof y.Arc?O(this,t):t instanceof y.Polygon?Q(this,t):t instanceof y.Multiline?it(this,t):void 0}distanceTo(t){if(t instanceof y.Point){let[e,n]=y.Distance.point2line(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Circle){let[e,n]=y.Distance.circle2line(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Segment){let[e,n]=y.Distance.segment2line(t,this);return[e,n.reverse()]}if(t instanceof y.Arc){let[e,n]=y.Distance.arc2line(t,this);return[e,n.reverse()]}if(t instanceof y.Polygon){let[e,n]=y.Distance.shape2polygon(this,t);return[e,n]}}split(t){if(t instanceof y.Point)return[new y.Ray(t,this.norm),new y.Ray(t,this.norm)];{let e=new y.Multiline([this]),n=this.sortPoints(t);return e.split(n),e.toShapes()}}rotate(t,e=new y.Point){return new y.Line(this.pt.rotate(t,e),this.norm.rotate(t))}transform(t){return new y.Line(this.pt.transform(t),this.norm.clone())}sortPoints(t){return t.slice().sort(((t,e)=>this.coord(t)<this.coord(e)?-1:this.coord(t)>this.coord(e)?1:0))}get name(){return"line"}svg(t,e={}){let n=N(this,t);if(0===n.length)return"";let i=n[0],r=2===n.length?n[1]:n.find((t=>!t.equalTo(i)));return void 0===r&&(r=i),new y.Segment(i,r).svg(e)}static points2norm(t,e){if(t.equalTo(e))throw w.ILLEGAL_PARAMETERS;return new y.Vector(t,e).normalize().rotate90CCW()}};y.Line=ve;const Ee=(...t)=>new y.Line(...t);y.line=Ee;let ye=class extends fe{constructor(...t){if(super(),this.pc=new y.Point,this.r=1,1===t.length&&t[0]instanceof Object&&"circle"===t[0].name){let{pc:e,r:n}=t[0];this.pc=new y.Point(e),this.r=n}else{let[e,n]=[...t];e&&e instanceof y.Point&&(this.pc=e.clone()),void 0!==n&&(this.r=n)}}clone(){return new y.Circle(this.pc.clone(),this.r)}get center(){return this.pc}get box(){return new y.Box(this.pc.x-this.r,this.pc.y-this.r,this.pc.x+this.r,this.pc.y+this.r)}contains(t){return t instanceof y.Point?y.Utils.LE(t.distanceTo(this.center)[0],this.r):t instanceof y.Segment?y.Utils.LE(t.start.distanceTo(this.center)[0],this.r)&&y.Utils.LE(t.end.distanceTo(this.center)[0],this.r):t instanceof y.Arc?0===this.intersect(t).length&&y.Utils.LE(t.start.distanceTo(this.center)[0],this.r)&&y.Utils.LE(t.end.distanceTo(this.center)[0],this.r):t instanceof y.Circle?0===this.intersect(t).length&&y.Utils.LE(t.r,this.r)&&y.Utils.LE(t.center.distanceTo(this.center)[0],this.r):void 0}toArc(t=!0){return new y.Arc(this.center,this.r,Math.PI,-Math.PI,t)}scale(t,e){if(t!==e)throw w.OPERATION_IS_NOT_SUPPORTED;if(0!==this.pc.x||0!==this.pc.y)throw w.OPERATION_IS_NOT_SUPPORTED;return new y.Circle(this.pc,this.r*t)}transform(t=new y.Matrix){return new y.Circle(this.pc.transform(t),this.r)}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Line?S(t,this):t instanceof y.Ray?X(t,this):t instanceof y.Segment?M(t,this):t instanceof y.Circle?k(t,this):t instanceof y.Box?function(t,e){let n=[];for(let i of e.toSegments()){let e=M(i,t);for(let t of e)n.push(t)}return n}(this,t):t instanceof y.Arc?B(t,this):t instanceof y.Polygon?W(this,t):t instanceof y.Multiline?it(this,t):void 0}distanceTo(t){if(t instanceof y.Point){let[e,n]=y.Distance.point2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Circle){let[e,n]=y.Distance.circle2circle(this,t);return[e,n]}if(t instanceof y.Line){let[e,n]=y.Distance.circle2line(this,t);return[e,n]}if(t instanceof y.Segment){let[e,n]=y.Distance.segment2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Arc){let[e,n]=y.Distance.arc2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Polygon){let[e,n]=y.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof y.PlanarSet){let[e,n]=y.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof y.Multiline){let[e,n]=y.Distance.shape2multiline(this,t);return[e,n]}}get name(){return"circle"}svg(t={}){return`\n<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}"\n                ${P({fill:"none",...t})} />`}};y.Circle=ye;const we=(...t)=>new y.Circle(...t);y.circle=we;class Ie extends fe{constructor(...t){if(super(),this.pc=new y.Point,this.r=1,this.startAngle=0,this.endAngle=2*Math.PI,this.counterClockwise=y.CCW,0!==t.length)if(1===t.length&&t[0]instanceof Object&&"arc"===t[0].name){let{pc:e,r:n,startAngle:i,endAngle:r,counterClockwise:s}=t[0];this.pc=new y.Point(e.x,e.y),this.r=n,this.startAngle=i,this.endAngle=r,this.counterClockwise=s}else{let[e,n,i,r,s]=[...t];e&&e instanceof y.Point&&(this.pc=e.clone()),void 0!==n&&(this.r=n),void 0!==i&&(this.startAngle=i),void 0!==r&&(this.endAngle=r),void 0!==s&&(this.counterClockwise=s)}}clone(){return new y.Arc(this.pc.clone(),this.r,this.startAngle,this.endAngle,this.counterClockwise)}get sweep(){if(y.Utils.EQ(this.startAngle,this.endAngle))return 0;if(y.Utils.EQ(Math.abs(this.startAngle-this.endAngle),y.PIx2))return y.PIx2;let t;return t=this.counterClockwise?y.Utils.GT(this.endAngle,this.startAngle)?this.endAngle-this.startAngle:this.endAngle-this.startAngle+y.PIx2:y.Utils.GT(this.startAngle,this.endAngle)?this.startAngle-this.endAngle:this.startAngle-this.endAngle+y.PIx2,y.Utils.GT(t,y.PIx2)&&(t-=y.PIx2),y.Utils.LT(t,0)&&(t+=y.PIx2),t}get start(){return new y.Point(this.pc.x+this.r,this.pc.y).rotate(this.startAngle,this.pc)}get end(){return new y.Point(this.pc.x+this.r,this.pc.y).rotate(this.endAngle,this.pc)}get center(){return this.pc.clone()}get vertices(){return[this.start.clone(),this.end.clone()]}get length(){return Math.abs(this.sweep*this.r)}get box(){let t=this.breakToFunctional().reduce(((t,e)=>t.merge(e.start.box)),new y.Box);return t=t.merge(this.end.box),t}contains(t){if(!y.Utils.EQ(this.pc.distanceTo(t)[0],this.r))return!1;if(t.equalTo(this.start))return!0;let e=new y.Vector(this.pc,t).slope,n=new y.Arc(this.pc,this.r,this.startAngle,e,this.counterClockwise);return y.Utils.LE(n.length,this.length)}split(t){if(this.start.equalTo(t))return[null,this.clone()];if(this.end.equalTo(t))return[this.clone(),null];let e=new y.Vector(this.pc,t).slope;return[new y.Arc(this.pc,this.r,this.startAngle,e,this.counterClockwise),new y.Arc(this.pc,this.r,e,this.endAngle,this.counterClockwise)]}middle(){let t=this.counterClockwise?this.startAngle+this.sweep/2:this.startAngle-this.sweep/2;return new y.Arc(this.pc,this.r,this.startAngle,t,this.counterClockwise).end}pointAtLength(t){if(t>this.length||t<0)return null;if(0===t)return this.start;if(t===this.length)return this.end;let e=t/this.length,n=this.counterClockwise?this.startAngle+this.sweep*e:this.startAngle-this.sweep*e;return new y.Arc(this.pc,this.r,this.startAngle,n,this.counterClockwise).end}chordHeight(){return(1-Math.cos(Math.abs(this.sweep/2)))*this.r}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Line?O(t,this):t instanceof y.Ray?K(t,this):t instanceof y.Circle?B(this,t):t instanceof y.Segment?R(t,this):t instanceof y.Box?function(t,e){let n=[];for(let i of e.toSegments()){let e=R(i,t);for(let t of e)n.push(t)}return n}(this,t):t instanceof y.Arc?D(this,t):t instanceof y.Polygon?Y(this,t):t instanceof y.Multiline?it(this,t):void 0}distanceTo(t){if(t instanceof y.Point){let[e,n]=y.Distance.point2arc(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Circle){let[e,n]=y.Distance.arc2circle(this,t);return[e,n]}if(t instanceof y.Line){let[e,n]=y.Distance.arc2line(this,t);return[e,n]}if(t instanceof y.Segment){let[e,n]=y.Distance.segment2arc(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Arc){let[e,n]=y.Distance.arc2arc(this,t);return[e,n]}if(t instanceof y.Polygon){let[e,n]=y.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof y.PlanarSet){let[e,n]=y.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof y.Multiline)return y.Distance.shape2multiline(this,t)}breakToFunctional(){let t=[],e=[0,Math.PI/2,2*Math.PI/2,3*Math.PI/2],n=[this.pc.translate(this.r,0),this.pc.translate(0,this.r),this.pc.translate(-this.r,0),this.pc.translate(0,-this.r)],i=[];for(let t=0;t<4;t++)n[t].on(this)&&i.push(new y.Arc(this.pc,this.r,this.startAngle,e[t],this.counterClockwise));if(0===i.length)t.push(this.clone());else{i.sort(((t,e)=>t.length-e.length));for(let e=0;e<i.length;e++){let n,r=t.length>0?t[t.length-1]:void 0;n=r?new y.Arc(this.pc,this.r,r.endAngle,i[e].endAngle,this.counterClockwise):new y.Arc(this.pc,this.r,this.startAngle,i[e].endAngle,this.counterClockwise),y.Utils.EQ_0(n.length)||t.push(n.clone())}let e,n=t.length>0?t[t.length-1]:void 0;e=n?new y.Arc(this.pc,this.r,n.endAngle,this.endAngle,this.counterClockwise):new y.Arc(this.pc,this.r,this.startAngle,this.endAngle,this.counterClockwise),y.Utils.EQ_0(e.length)||y.Utils.EQ(e.sweep,2*Math.PI)||t.push(e.clone())}return t}tangentInStart(){let t=new y.Vector(this.pc,this.start),e=this.counterClockwise?Math.PI/2:-Math.PI/2;return t.rotate(e).normalize()}tangentInEnd(){let t=new y.Vector(this.pc,this.end),e=this.counterClockwise?-Math.PI/2:Math.PI/2;return t.rotate(e).normalize()}reverse(){return new y.Arc(this.pc,this.r,this.endAngle,this.startAngle,!this.counterClockwise)}transform(t=new y.Matrix){let e=this.start.transform(t),n=this.end.transform(t),i=this.pc.transform(t),r=this.counterClockwise;return t.a*t.d<0&&(r=!r),y.Arc.arcSE(i,e,n,r)}static arcSE(t,e,n,i){let{vector:r}=y,s=r(t,e).slope,o=r(t,n).slope;y.Utils.EQ(s,o)&&(o+=2*Math.PI,i=!0);let a=r(t,e).length;return new y.Arc(t,a,s,o,i)}definiteIntegral(t=0){let e=this.breakToFunctional().reduce(((e,n)=>e+n.circularSegmentDefiniteIntegral(t)),0);return e}circularSegmentDefiniteIntegral(t){let e=new y.Line(this.start,this.end),n=this.pc.leftTo(e),i=new y.Segment(this.start,this.end).definiteIntegral(t),r=this.circularSegmentArea();return n?i-r:i+r}circularSegmentArea(){return.5*this.r*this.r*(this.sweep-Math.sin(this.sweep))}sortPoints(t){let{vector:e}=y;return t.slice().sort(((t,n)=>{let i=e(this.pc,t).slope,r=e(this.pc,n).slope;return i<r?-1:i>r?1:0}))}get name(){return"arc"}svg(t={}){let e=this.sweep<=Math.PI?"0":"1",n=this.counterClockwise?"1":"0";if(y.Utils.EQ(this.sweep,2*Math.PI)){return new y.Circle(this.pc,this.r).svg(t)}return`\n<path d="M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${e},${n} ${this.end.x},${this.end.y}"\n                    ${P({fill:"none",...t})} />`}}y.Arc=Ie;const be=(...t)=>new y.Arc(...t);y.arc=be;class Te extends fe{constructor(t=void 0,e=void 0,n=void 0,i=void 0){super(),this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=i}clone(){return new Te(this.xmin,this.ymin,this.xmax,this.ymax)}get low(){return new y.Point(this.xmin,this.ymin)}get high(){return new y.Point(this.xmax,this.ymax)}get max(){return this.clone()}get center(){return new y.Point((this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)}get width(){return Math.abs(this.xmax-this.xmin)}get height(){return Math.abs(this.ymax-this.ymin)}get box(){return this.clone()}not_intersect(t){return this.xmax<t.xmin||this.xmin>t.xmax||this.ymax<t.ymin||this.ymin>t.ymax}intersect(t){return!this.not_intersect(t)}merge(t){return new Te(void 0===this.xmin?t.xmin:Math.min(this.xmin,t.xmin),void 0===this.ymin?t.ymin:Math.min(this.ymin,t.ymin),void 0===this.xmax?t.xmax:Math.max(this.xmax,t.xmax),void 0===this.ymax?t.ymax:Math.max(this.ymax,t.ymax))}less_than(t){return!!this.low.lessThan(t.low)||!(!this.low.equalTo(t.low)||!this.high.lessThan(t.high))}equal_to(t){return this.low.equalTo(t.low)&&this.high.equalTo(t.high)}output(){return this.clone()}static comparable_max(t,e){return t.merge(e)}static comparable_less_than(t,e){return t.lessThan(e)}set(t,e,n,i){this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=i}toPoints(){return[new y.Point(this.xmin,this.ymin),new y.Point(this.xmax,this.ymin),new y.Point(this.xmax,this.ymax),new y.Point(this.xmin,this.ymax)]}toSegments(){let t=this.toPoints();return[new y.Segment(t[0],t[1]),new y.Segment(t[1],t[2]),new y.Segment(t[2],t[3]),new y.Segment(t[3],t[0])]}rotate(t,e=new y.Point){throw w.OPERATION_IS_NOT_SUPPORTED}transform(t=new y.Matrix){return this.toPoints().map((e=>e.transform(t))).reduce(((t,e)=>t.merge(e.box)),new Te)}contains(t){return t instanceof y.Point?t.x>=this.xmin&&t.x<=this.xmax&&t.y>=this.ymin&&t.y<=this.ymax:t instanceof y.Segment?t.vertices.every((t=>this.contains(t))):t instanceof y.Box?t.toSegments().every((t=>this.contains(t))):t instanceof y.Circle?this.contains(t.box):t instanceof y.Arc?t.vertices.every((t=>this.contains(t)))&&t.toSegments().every((e=>0===R(e,t).length)):!(t instanceof y.Line||t instanceof y.Ray)&&(t instanceof y.Multiline?t.toShapes().every((t=>this.contains(t))):t instanceof y.Polygon?this.contains(t.box):void 0)}distanceTo(t){const e=this.toSegments().map((e=>e.distanceTo(t)));let n=[Number.MAX_SAFE_INTEGER,null];return e.forEach((t=>{t[0]<n[0]&&(n=t)})),n}get name(){return"box"}svg(t={}){const e=this.xmax-this.xmin,n=this.ymax-this.ymin;return`\n<rect x="${this.xmin}" y="${this.ymin}" width="${e}" height="${n}"\n                ${P({fill:"none",...t})} />`}}y.Box=Te;const Pe=(...t)=>new y.Box(...t);y.box=Pe;class Ae{constructor(t){this.shape=t,this.next=void 0,this.prev=void 0,this.face=void 0,this.arc_length=0,this.bvStart=void 0,this.bvEnd=void 0,this.bv=void 0,this.overlap=void 0}get start(){return this.shape.start}get end(){return this.shape.end}get length(){return this.shape.length}get box(){return this.shape.box}get isSegment(){return this.shape instanceof y.Segment}get isArc(){return this.shape instanceof y.Arc}get isLine(){return this.shape instanceof y.Line}get isRay(){return this.shape instanceof y.Ray}middle(){return this.shape.middle()}pointAtLength(t){return this.shape.pointAtLength(t)}contains(t){return this.shape.contains(t)}setInclusion(t){if(void 0!==this.bv)return this.bv;if(this.shape instanceof y.Line||this.shape instanceof y.Ray)return this.bv=y.OUTSIDE,this.bv;if(void 0===this.bvStart&&(this.bvStart=Jt(t,this.start)),void 0===this.bvEnd&&(this.bvEnd=Jt(t,this.end)),this.bvStart===y.OUTSIDE||this.bvEnd==y.OUTSIDE)this.bv=y.OUTSIDE;else if(this.bvStart===y.INSIDE||this.bvEnd==y.INSIDE)this.bv=y.INSIDE;else{let e=Jt(t,this.middle());this.bv=e}return this.bv}setOverlap(t){let e,n=this.shape,i=t.shape;n instanceof y.Segment&&i instanceof y.Segment?n.start.equalTo(i.start)&&n.end.equalTo(i.end)?e=y.OVERLAP_SAME:n.start.equalTo(i.end)&&n.end.equalTo(i.start)&&(e=y.OVERLAP_OPPOSITE):(n instanceof y.Arc&&i instanceof y.Arc||n instanceof y.Segment&&i instanceof y.Arc||n instanceof y.Arc&&i instanceof y.Segment)&&(n.start.equalTo(i.start)&&n.end.equalTo(i.end)&&n.middle().equalTo(i.middle())?e=y.OVERLAP_SAME:n.start.equalTo(i.end)&&n.end.equalTo(i.start)&&n.middle().equalTo(i.middle())&&(e=y.OVERLAP_OPPOSITE)),void 0===this.overlap&&(this.overlap=e),void 0===t.overlap&&(t.overlap=e)}svg(){if(this.shape instanceof y.Segment)return` L${this.shape.end.x},${this.shape.end.y}`;if(this.shape instanceof y.Arc){let t,e=this.shape,n=e.counterClockwise?"1":"0";if(y.Utils.EQ(e.sweep,2*Math.PI)){let i=e.counterClockwise?1:-1,r=new y.Arc(e.pc,e.r,e.startAngle,e.startAngle+i*Math.PI,e.counterClockwise),s=new y.Arc(e.pc,e.r,e.startAngle+i*Math.PI,e.endAngle,e.counterClockwise);return t="0",` A${r.r},${r.r} 0 ${t},${n} ${r.end.x},${r.end.y}\n                    A${s.r},${s.r} 0 ${t},${n} ${s.end.x},${s.end.y}`}return t=e.sweep<=Math.PI?"0":"1",` A${e.r},${e.r} 0 ${t},${n} ${e.end.x},${e.end.y}`}}toJSON(){return this.shape.toJSON()}}y.Edge=Ae;class Se extends I{constructor(t,e){super(t,e),this.setCircularLinks()}setCircularLinks(){this.isEmpty()||(this.last.next=this.first,this.first.prev=this.last)}[Symbol.iterator](){let t;return{next:()=>{let e=t||this.first,n=!this.first||!!t&&t===this.first;return t=e?e.next:void 0,{value:e,done:n}}}}append(t){return super.append(t),this.setCircularLinks(),this}insert(t,e){return super.insert(t,e),this.setCircularLinks(),this}remove(t){return super.remove(t),this}}class Ne extends Se{constructor(e,...n){if(super(),this._box=void 0,this._orientation=void 0,0!==n.length){if(1===n.length)if(n[0]instanceof Array){let t=n[0];if(0===t.length)return;if(t.every((t=>t instanceof y.Point))){let n=Ne.points2segments(t);this.shapes2face(e.edges,n)}else if(t.every((t=>t instanceof Array&&2===t.length))){let n=t.map((t=>new y.Point(t[0],t[1]))),i=Ne.points2segments(n);this.shapes2face(e.edges,i)}else if(t.every((t=>t instanceof y.Segment||t instanceof y.Arc)))this.shapes2face(e.edges,t);else if(t.every((t=>"segment"===t.name||"arc"===t.name))){let n=[];for(let e of t){let t;t="segment"===e.name?new y.Segment(e):new y.Arc(e),n.push(t)}this.shapes2face(e.edges,n)}}else if(n[0]instanceof Ne){let t=n[0];this.first=t.first,this.last=t.last;for(let n of t)e.edges.add(n)}else if(n[0]instanceof y.Circle)this.shapes2face(e.edges,[n[0].toArc(t)]);else if(n[0]instanceof y.Box){let t=n[0];this.shapes2face(e.edges,[new y.Segment(new y.Point(t.xmin,t.ymin),new y.Point(t.xmax,t.ymin)),new y.Segment(new y.Point(t.xmax,t.ymin),new y.Point(t.xmax,t.ymax)),new y.Segment(new y.Point(t.xmax,t.ymax),new y.Point(t.xmin,t.ymax)),new y.Segment(new y.Point(t.xmin,t.ymax),new y.Point(t.xmin,t.ymin))])}2===n.length&&n[0]instanceof y.Edge&&n[1]instanceof y.Edge&&(this.first=n[0],this.last=n[1],this.last.next=this.first,this.first.prev=this.last,this.setArcLength())}}get edges(){return this.toArray()}get shapes(){return this.edges.map((t=>t.shape.clone()))}get box(){if(void 0===this._box){let t=new y.Box;for(let e of this)t=t.merge(e.box);this._box=t}return this._box}get perimeter(){return this.last.arc_length+this.last.length}pointAtLength(t){if(t>this.perimeter||t<0)return null;let e=null;for(let n of this)if(t>=n.arc_length&&(n===this.last||t<n.next.arc_length)){e=n.pointAtLength(t-n.arc_length);break}return e}static points2segments(t){let e=[];for(let n=0;n<t.length;n++)t[n].equalTo(t[(n+1)%t.length])||e.push(new y.Segment(t[n],t[(n+1)%t.length]));return e}shapes2face(t,e){for(let n of e){let e=new y.Edge(n);this.append(e),t.add(e)}}append(t){return super.append(t),this.setOneEdgeArcLength(t),t.face=this,this}insert(t,e){return super.insert(t,e),this.setOneEdgeArcLength(t),t.face=this,this}remove(t){return super.remove(t),this.setArcLength(),this}merge_with_next_edge(t){return t.shape.end.x=t.next.shape.end.x,t.shape.end.y=t.next.shape.end.y,this.remove(t.next),this}reverse(){let t=[],e=this.last;do{e.shape=e.shape.reverse(),t.push(e),e=e.prev}while(e!==this.last);this.first=void 0,this.last=void 0;for(let e of t)void 0===this.first?(e.prev=e,e.next=e,this.first=e,this.last=e):(e.prev=this.last,this.last.next=e,this.last=e,this.last.next=this.first,this.first.prev=this.last),this.setOneEdgeArcLength(e);void 0!==this._orientation&&(this._orientation=void 0,this._orientation=this.orientation())}setArcLength(){for(let t of this)this.setOneEdgeArcLength(t),t.face=this}setOneEdgeArcLength(t){t===this.first?t.arc_length=0:t.arc_length=t.prev.arc_length+t.prev.length}area(){return Math.abs(this.signedArea())}signedArea(){let t=0,e=this.box.ymin;for(let n of this)t+=n.shape.definiteIntegral(e);return t}orientation(){if(void 0===this._orientation){let t=this.signedArea();y.Utils.EQ_0(t)?this._orientation=n.NOT_ORIENTABLE:y.Utils.LT(t,0)?this._orientation=n.CCW:this._orientation=n.CW}return this._orientation}isSimple(t){return 0===Ne.getSelfIntersections(this,t,!0).length}static getSelfIntersections(t,e,n=!1){let i=[];for(let r of t){let s=e.search(r.box);for(let e of s){if(r===e)continue;if(e.face!==t)continue;if(r.shape instanceof y.Segment&&e.shape instanceof y.Segment&&(r.next===e||r.prev===e))continue;let s=r.shape.intersect(e.shape);for(let t of s)if((!t.equalTo(r.start)||!t.equalTo(e.end)||e!==r.prev)&&(!t.equalTo(r.end)||!t.equalTo(e.start)||e!==r.next)&&(i.push(t),n))break;if(i.length>0&&n)break}if(i.length>0&&n)break}return i}findEdgeByPoint(t){let e;for(let n of this)if(!t.equalTo(n.shape.start)&&(t.equalTo(n.shape.end)||n.shape.contains(t))){e=n;break}return e}toPolygon(){return new y.Polygon(this.shapes)}toJSON(){return this.edges.map((t=>t.toJSON()))}svg(){let t=`M${this.first.start.x},${this.first.start.y}`;for(let e of this)t+=e.svg();return t+=" z",t}}y.Face=Ne;class Oe extends fe{constructor(...t){if(super(),this.pt=new y.Point,this.norm=new y.Vector(0,1),0!==t.length&&(t.length>=1&&t[0]instanceof y.Point&&(this.pt=t[0].clone()),1!==t.length)){if(!(2===t.length&&t[1]instanceof y.Vector))throw w.ILLEGAL_PARAMETERS;this.norm=t[1].clone()}}clone(){return new Oe(this.pt,this.norm)}get slope(){return new y.Vector(this.norm.y,-this.norm.x).slope}get box(){let t=this.slope;return new y.Box(t>Math.PI/2&&t<3*Math.PI/2?Number.NEGATIVE_INFINITY:this.pt.x,t>=0&&t<=Math.PI?this.pt.y:Number.NEGATIVE_INFINITY,t>=Math.PI/2&&t<=3*Math.PI/2?this.pt.x:Number.POSITIVE_INFINITY,t>=Math.PI&&t<=2*Math.PI||0===t?this.pt.y:Number.POSITIVE_INFINITY)}get start(){return this.pt}get end(){}get length(){return Number.POSITIVE_INFINITY}contains(t){if(this.pt.equalTo(t))return!0;let e=new y.Vector(this.pt,t);return y.Utils.EQ_0(this.norm.dot(e))&&y.Utils.GE(e.cross(this.norm),0)}coord(t){return ge(t.x,t.y).cross(this.norm)}split(t){return this.contains(t)?this.pt.equalTo(t)?[this]:[new y.Segment(this.pt,t),new y.Ray(t,this.norm)]:[]}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Segment?J(this,t):t instanceof y.Arc?K(this,t):t instanceof y.Line?tt(this,t):t instanceof y.Ray?(n=t,A(Z(e=this),Z(n)).filter((t=>e.contains(t))).filter((t=>n.contains(t)))):t instanceof y.Circle?X(this,t):t instanceof y.Box?function(t,e){return N(Z(t),e).filter((e=>t.contains(e)))}(this,t):t instanceof y.Polygon?et(this,t):void 0;var e,n}rotate(t,e=new y.Point){return new y.Ray(this.pt.rotate(t,e),this.norm.rotate(t))}transform(t){return new y.Ray(this.pt.transform(t),this.norm.clone())}get name(){return"ray"}svg(t,e={}){let n=N(new y.Line(this.pt,this.norm),t);return n=n.filter((t=>this.contains(t))),0===n.length||2===n.length?"":new y.Segment(this.pt,n[0]).svg(e)}}y.Ray=Oe;const Le=(...t)=>new y.Ray(...t);y.ray=Le;let Ce=class t{constructor(){this.faces=new y.PlanarSet,this.edges=new y.PlanarSet;let t=[...arguments];if(1===t.length&&(t[0]instanceof Array&&t[0].length>0||t[0]instanceof y.Circle||t[0]instanceof y.Box)){let e=t[0];if(t[0]instanceof Array&&t[0].every((t=>t instanceof Array)))if(e.every((t=>t instanceof Array&&2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])))this.faces.add(new y.Face(this,e));else for(let t of e)if(t instanceof Array&&t[0]instanceof Array&&t[0].every((t=>t instanceof Array&&2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])))for(let e of t)this.faces.add(new y.Face(this,e));else this.faces.add(new y.Face(this,t));else this.faces.add(new y.Face(this,e))}}get box(){return[...this.faces].reduce(((t,e)=>t.merge(e.box)),new y.Box)}get vertices(){return[...this.edges].map((t=>t.start))}clone(){let e=new t;for(let t of this.faces)e.addFace(t.shapes);return e}isEmpty(){return 0===this.edges.size}isValid(){let t=!0;for(let e of this.faces)if(!e.isSimple(this.edges)){t=!1;break}return t}area(){let t=[...this.faces].reduce(((t,e)=>t+e.signedArea()),0);return Math.abs(t)}addFace(...t){let e=new y.Face(this,...t);return this.faces.add(e),e}deleteFace(t){for(let e of t)this.edges.delete(e);return this.faces.delete(t)}recreateFaces(){this.faces.clear();for(let t of this.edges)t.face=null;let t,e=!0;for(;e;){e=!1;for(let n of this.edges)if(null===n.face){t=n,e=!0;break}if(e){let e=t;do{e=e.next}while(e.next!==t);this.addFace(t,e)}}}removeChain(t,e,n){if(n.next!==e){for(let i=e;i!==n.next;i=i.next)if(t.remove(i),this.edges.delete(i),t.isEmpty()){this.deleteFace(t);break}}else this.deleteFace(t)}addVertex(t,e){let n=e.shape.split(t);if(null===n[0])return e.prev;if(null===n[1])return e;let i=new y.Edge(n[0]),r=e.prev;return e.face.insert(i,r),this.edges.delete(e),this.edges.add(i),e.shape=n[1],this.edges.add(e),i}removeEndVertex(t){const e=t.next;e!==t&&(t.face.merge_with_next_edge(t),this.edges.delete(e))}cut(t){let e,n,i=this.clone(),s={int_points1:[],int_points2:[],int_points1_sorted:[],int_points2_sorted:[]};for(let e of t.edges)for(let t of i.edges){let n=z(e,t);for(let i of n)ot(e,i,s.int_points1),ot(t,i,s.int_points2)}if(0===s.int_points1.length)return i;s.int_points1_sorted=lt(s.int_points1),s.int_points2_sorted=lt(s.int_points2),gt(t,s.int_points1_sorted),gt(i,s.int_points2_sorted),ct(s),s.int_points1_sorted=lt(s.int_points1),s.int_points2_sorted=lt(s.int_points2),ft(s.int_points1),ut(s.int_points1,i);for(let t of s.int_points1_sorted)t.edge_before&&t.edge_after&&t.edge_before.bv===t.edge_after.bv&&(s.int_points2[t.id]=-1,t.id=-1);if(s.int_points1=s.int_points1.filter((t=>t.id>=0)),s.int_points2=s.int_points2.filter((t=>t.id>=0)),s.int_points1.forEach(((t,e)=>{t.id=e})),s.int_points2.forEach(((t,e)=>{t.id=e})),0===s.int_points1.length)return i;s.int_points1_sorted=lt(s.int_points1),s.int_points2_sorted=lt(s.int_points2);for(let o=1;o<s.int_points1_sorted.length;o++)if(n=s.int_points1_sorted[o],e=s.int_points1_sorted[o-1],n.edge_before&&n.edge_before.bv===r){let r=e.edge_after,o=n.edge_before,a=t.getChain(r,o);mt(s.int_points2[e.id],s.int_points2[n.id],a),a.forEach((t=>i.edges.add(t))),a=a.reverse().map((t=>new y.Edge(t.shape.reverse())));for(let t=0;t<a.length-1;t++)a[t].next=a[t+1],a[t+1].prev=a[t];mt(s.int_points2[n.id],s.int_points2[e.id],a),a.forEach((t=>i.edges.add(t)))}return i.recreateFaces(),i}cutWithLine(t){let e=new rt([t]);return this.cut(e)}findEdgeByPoint(t){let e;for(let n of this.faces)if(e=n.findEdgeByPoint(t),void 0!==e)break;return e}splitToIslands(){if(this.isEmpty())return[];let t=this.toArray();t.sort(((t,e)=>e.area()-t.area()));let e=[...t[0].faces][0].orientation(),n=t.filter((t=>[...t.faces][0].orientation()===e));for(let i of t){let t=[...i.faces][0];if(t.orientation()!==e)for(let e of n)if(t.shapes.every((t=>e.contains(t)))){e.addFace(t.shapes);break}}return n}reverse(){for(let t of this.faces)t.reverse();return this}contains(t){if(t instanceof y.Point){let e=Jt(this,t);return e===r||e===o}return ee(this,t)}distanceTo(t){if(t instanceof y.Point){let[e,n]=y.Distance.point2polygon(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Circle||t instanceof y.Line||t instanceof y.Segment||t instanceof y.Arc){let[e,n]=y.Distance.shape2polygon(t,this);return n=n.reverse(),[e,n]}if(t instanceof y.Polygon){let e,n,i=[Number.POSITIVE_INFINITY,new y.Segment];for(let r of this.edges){let s=i[0];[e,n]=y.Distance.shape2planarSet(r.shape,t.edges,s),y.Utils.LT(e,s)&&(i=[e,n])}return i}}intersect(t){return t instanceof y.Point?this.contains(t)?[t]:[]:t instanceof y.Line?Q(t,this):t instanceof y.Ray?et(t,this):t instanceof y.Circle?W(t,this):t instanceof y.Segment?G(t,this):t instanceof y.Arc?Y(t,this):t instanceof y.Polygon?function(t,e){let n=[];if(t.isEmpty()||e.isEmpty())return n;if(t.box.not_intersect(e.box))return n;for(let i of t.edges)n=[...n,...j(i,e)];return n}(t,this):t instanceof y.Multiline?function(t,e){let n=[];if(e.isEmpty()||0===t.size)return n;for(let i of t)n=[...n,...j(i,e)];return n}(t,this):void 0}translate(e){let n=new t;for(let t of this.faces)n.addFace(t.shapes.map((t=>t.translate(e))));return n}rotate(e=0,n=new y.Point){let i=new t;for(let t of this.faces)i.addFace(t.shapes.map((t=>t.rotate(e,n))));return i}scale(e,n){let i=new t;for(let t of this.faces)i.addFace(t.shapes.map((t=>t.scale(e,n))));return i}transform(e=new y.Matrix){let n=new t;for(let t of this.faces)n.addFace(t.shapes.map((t=>t.transform(e))));return n}toJSON(){return[...this.faces].map((t=>t.toJSON()))}toArray(){return[...this.faces].map((t=>t.toPolygon()))}dpath(){return[...this.faces].reduce(((t,e)=>t+e.svg()),"")}svg(t={}){let e=`\n<path ${P({fillRule:"evenodd",fill:"lightcyan",...t})} d="`;for(let t of this.faces)e+=`\n${t.svg()}`;return e+='" >\n</path>',e}};y.Polygon=Ce;const Ue=(...t)=>new y.Polygon(...t);y.polygon=Ue;const{Circle:Me,Line:Re,Point:ke,Vector:De,Utils:Be}=y;class Ve{constructor(t){this.circle=t}get inversion_circle(){return this.circle}static inversePoint(t,e){const n=new De(t.pc,e),i=t.r*t.r,r=n.dot(n);return Be.EQ_0(r)?new ke(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY):t.pc.translate(n.multiply(i/r))}static inverseCircle(t,e){const n=t.pc.distanceTo(e.pc)[0];if(Be.EQ(n,e.r)){let n=t.r*t.r/(2*e.r),i=new De(t.pc,e.pc);i=i.normalize();let r=t.pc.translate(i.multiply(n));return new Re(r,i)}{let n=new De(t.pc,e.pc),i=t.r*t.r/(n.dot(n)-e.r*e.r),r=t.pc.translate(n.multiply(i)),s=Math.abs(i)*e.r;return new Me(r,s)}}static inverseLine(t,e){const[n,i]=t.pc.distanceTo(e);if(Be.EQ_0(n))return e.clone();{let e=t.r*t.r/(2*n),r=new De(t.pc,i.end);return r=r.multiply(e/n),new Me(t.pc.translate(r),e)}}inverse(t){return t instanceof ke?Ve.inversePoint(this.circle,t):t instanceof Me?Ve.inverseCircle(this.circle,t):t instanceof Re?Ve.inverseLine(this.circle,t):void 0}}y.Inversion=Ve;const Fe=t=>new y.Inversion(t);y.inversion=Fe;class qe{static point2point(t,e){return t.distanceTo(e)}static point2line(t,e){let n=t.projectionOn(e);return[new y.Vector(t,n).length,new y.Segment(t,n)]}static point2circle(t,e){let[n,i]=t.distanceTo(e.center);if(y.Utils.EQ_0(n))return[e.r,new y.Segment(t,e.toArc().start)];{let i=Math.abs(n-e.r),r=new y.Vector(e.pc,t).normalize().multiply(e.r),s=e.pc.translate(r);return[i,new y.Segment(t,s)]}}static point2segment(t,e){if(e.start.equalTo(e.end))return qe.point2point(t,e.start);let n,i,r=new y.Vector(e.start,e.end),s=new y.Vector(e.start,t),o=new y.Vector(e.end,t),a=r.dot(s),l=-r.dot(o);if(y.Utils.GE(a,0)&&y.Utils.GE(l,0)){let r=e.tangentInStart();return n=Math.abs(r.cross(s)),i=e.start.translate(r.multiply(r.dot(s))),[n,new y.Segment(t,i)]}return a<0?t.distanceTo(e.start):t.distanceTo(e.end)}static point2arc(t,e){let n,i,r=new y.Circle(e.pc,e.r),s=[];return[n,i]=qe.point2circle(t,r),i.end.on(e)&&s.push(qe.point2circle(t,r)),s.push(qe.point2point(t,e.start)),s.push(qe.point2point(t,e.end)),qe.sort(s),s[0]}static point2edge(t,e){return e.shape instanceof y.Segment?qe.point2segment(t,e.shape):qe.point2arc(t,e.shape)}static segment2line(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=[];return i.push(qe.point2line(t.start,e)),i.push(qe.point2line(t.end,e)),qe.sort(i),i[0]}static segment2segment(t,e){let n=C(t,e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i,r,s=[];return[i,r]=qe.point2segment(e.start,t),s.push([i,r.reverse()]),[i,r]=qe.point2segment(e.end,t),s.push([i,r.reverse()]),s.push(qe.point2segment(t.start,e)),s.push(qe.point2segment(t.end,e)),qe.sort(s),s[0]}static segment2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=new y.Line(t.ps,t.pe),[r,s]=qe.point2line(e.center,i);if(y.Utils.GE(r,e.r)&&s.end.on(t))return qe.point2circle(s.end,e);{let[n,i]=qe.point2circle(t.start,e),[r,s]=qe.point2circle(t.end,e);return y.Utils.LT(n,r)?[n,i]:[r,s]}}static segment2arc(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=new y.Line(t.ps,t.pe),r=new y.Circle(e.pc,e.r),[s,o]=qe.point2line(r.center,i);if(y.Utils.GE(s,r.r)&&o.end.on(t)){let[t,n]=qe.point2circle(o.end,r);if(n.end.on(e))return[t,n]}let a,l,h=[];return h.push(qe.point2arc(t.start,e)),h.push(qe.point2arc(t.end,e)),[a,l]=qe.point2segment(e.start,t),h.push([a,l.reverse()]),[a,l]=qe.point2segment(e.end,t),h.push([a,l.reverse()]),qe.sort(h),h[0]}static circle2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];if(t.center.equalTo(e.center)){let n=t.toArc(),i=e.toArc();return qe.point2point(n.start,i.start)}{let n=new y.Line(t.center,e.center),i=n.intersect(t),r=n.intersect(e),s=[];return s.push(qe.point2point(i[0],r[0])),s.push(qe.point2point(i[0],r[1])),s.push(qe.point2point(i[1],r[0])),s.push(qe.point2point(i[1],r[1])),qe.sort(s),s[0]}}static circle2line(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let[i,r]=qe.point2line(t.center,e),[s,o]=qe.point2circle(r.end,t);return o=o.reverse(),[s,o]}static arc2line(t,e){let n=e.intersect(t);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=new y.Circle(t.center,t.r),[r,s]=qe.point2line(i.center,e);if(!y.Utils.GE(r,i.r)){let n=[];return n.push(qe.point2line(t.start,e)),n.push(qe.point2line(t.end,e)),qe.sort(n),n[0]}{let[e,n]=qe.point2circle(s.end,i);if(n.end.on(t))return[e,n]}}static arc2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=new y.Circle(t.center,t.r),[r,s]=qe.circle2circle(i,e);if(s.start.on(t))return[r,s];{let n=[];return n.push(qe.point2circle(t.start,e)),n.push(qe.point2circle(t.end,e)),qe.sort(n),n[0]}}static arc2arc(t,e){let n=t.intersect(e);if(n.length>0)return[0,new y.Segment(n[0],n[0])];let i=new y.Circle(t.center,t.r),r=new y.Circle(e.center,e.r),[s,o]=qe.circle2circle(i,r);if(o.start.on(t)&&o.end.on(e))return[s,o];{let n,i,r=[];return[n,i]=qe.point2arc(t.start,e),i.end.on(e)&&r.push([n,i]),[n,i]=qe.point2arc(t.end,e),i.end.on(e)&&r.push([n,i]),[n,i]=qe.point2arc(e.start,t),i.end.on(t)&&r.push([n,i.reverse()]),[n,i]=qe.point2arc(e.end,t),i.end.on(t)&&r.push([n,i.reverse()]),[n,i]=qe.point2point(t.start,e.start),r.push([n,i]),[n,i]=qe.point2point(t.start,e.end),r.push([n,i]),[n,i]=qe.point2point(t.end,e.start),r.push([n,i]),[n,i]=qe.point2point(t.end,e.end),r.push([n,i]),qe.sort(r),r[0]}}static point2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new y.Segment];for(let i of e.edges){let[e,r]=qe.point2edge(t,i);y.Utils.LT(e,n[0])&&(n=[e,r])}return n}static shape2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new y.Segment];for(let i of e.edges){let[e,r]=t.distanceTo(i.shape);y.Utils.LT(e,n[0])&&(n=[e,r])}return n}static polygon2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new y.Segment];for(let i of t.edges)for(let t of e.edges){let[e,r]=i.shape.distanceTo(t.shape);y.Utils.LT(e,n[0])&&(n=[e,r])}return n}static box2box_minmax(t,e){let n=Math.max(Math.max(t.xmin-e.xmax,0),Math.max(e.xmin-t.xmax,0)),i=Math.max(Math.max(t.ymin-e.ymax,0),Math.max(e.ymin-t.ymax,0)),r=n*n+i*i,s=t.merge(e),o=s.xmax-s.xmin,a=s.ymax-s.ymin;return[r,o*o+a*a]}static minmax_tree_process_level(t,e,n,i){let r,s;for(let o of e)[r,s]=qe.box2box_minmax(t.box,o.item.key),o.item.value instanceof y.Edge?i.insert([r,s],o.item.value.shape):i.insert([r,s],o.item.value),y.Utils.LT(s,n)&&(n=s);if(0===e.length)return n;let o=[...e.map((t=>t.left.isNil()?void 0:t.left)).filter((t=>void 0!==t)),...e.map((t=>t.right.isNil()?void 0:t.right)).filter((t=>void 0!==t))].filter((e=>{let[i,r]=qe.box2box_minmax(t.box,e.max);return y.Utils.LE(i,n)}));return n=qe.minmax_tree_process_level(t,o,n,i)}static minmax_tree(t,e,n){let i=new he,r=[e.index.root],s=n<Number.POSITIVE_INFINITY?n*n:Number.POSITIVE_INFINITY;return s=qe.minmax_tree_process_level(t,r,s,i),i}static minmax_tree_calc_distance(t,e,n){let i,r;if(null!=e&&!e.isNil()){if([i,r]=qe.minmax_tree_calc_distance(t,e.left,n),r)return[i,r];if(y.Utils.LT(i[0],Math.sqrt(e.item.key.low)))return[i,!0];let[s,o]=qe.distance(t,e.item.value);return y.Utils.LT(s,i[0])&&(i=[s,o]),[i,r]=qe.minmax_tree_calc_distance(t,e.right,i),[i,r]}return[n,!1]}static shape2planarSet(t,e,n=Number.POSITIVE_INFINITY){let i=[n,new y.Segment],r=!1;if(e instanceof y.PlanarSet){let s=qe.minmax_tree(t,e,n);[i,r]=qe.minmax_tree_calc_distance(t,s.root,i)}return i}static sort(t){t.sort(((t,e)=>y.Utils.LT(t[0],e[0])?-1:y.Utils.GT(t[0],e[0])?1:0))}static distance(t,e){return t.distanceTo(e)}static shape2multiline(t,e){let n=[Number.POSITIVE_INFINITY,new y.Segment];for(let i of e){let[e,r]=qe.distance(t,i.shape);y.Utils.LT(e,n[0])&&(n=[e,r])}return n}static multiline2multiline(t,e){let n=[Number.POSITIVE_INFINITY,new y.Segment];for(let i of t)for(let t of e){let[e,r]=qe.distance(i.shape,t.shape);y.Utils.LT(e,n[0])&&(n=[e,r])}return n}}y.Distance=qe;const{Multiline:$e,Point:Ge,Segment:Ye,Polygon:Qe}=y;function We(t){return new Ge(t.split(" ").map(Number))}function ze(t){return t.split(", ").map(We)}function je(t){const e=ze(t);let n=[];for(let t=0;t<e.length-1;t++)n.push(new Ye(e[t],e[t+1]));return new $e(n)}function He(t){const e=t.replace(/\(\(/,"").replace(/\)\)$/,"").split("), ("),n=new Qe;let i;return e.forEach(((t,e)=>{let r=t.split(", ").map((t=>new Ge(t.split(" ").map(Number))));const s=n.addFace(r);0===e?i=s.orientation():s.orientation()===i&&s.reverse()})),n}function Ze(t){if(t.startsWith("POLYGON")){return He(t.replace(/^POLYGON /,""))}return function(t){const e=t.split(/\)\), \(\(/).map((t=>"(("+t+"))")),n=e.map(He),i=new Qe,r=n.reduce(((t,e)=>[...t,...e?.faces]),[]);return r.forEach((t=>i.addFace([...t?.shapes]))),i}(t.replace(/^MULTIPOLYGON \(\(\((.*)\)\)\)$/,"$1"))}function Je(t){if(t.startsWith("POINT")){return We(t.replace(/^POINT \(/,"").replace(/\)$/,""))}if(t.startsWith("MULTIPOINT")){return ze(t.replace(/^MULTIPOINT \(/,"").replace(/\)$/,""))}if(t.startsWith("LINESTRING")){return je(t.replace(/^LINESTRING \(/,"").replace(/\)$/,""))}if(t.startsWith("MULTILINESTRING")){return function(t){return t.replace(/\(\(/,"").replace(/\)\)$/,"").split("), (").map(je)}(t.replace(/^MULTILINESTRING /,""))}if(t.startsWith("POLYGON")||t.startsWith("MULTIPOLYGON"))return Ze(t);if(t.startsWith("GEOMETRYCOLLECTION")){const e=/(?<type>POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON) \((?:[^\(\)]|\([^\)]*\))*\)/g,n=t.match(e);n[0].startsWith("GEOMETRYCOLLECTION")&&(n[0]=n[0].replace("GEOMETRYCOLLECTION (",""));return n.map(Je).map((t=>t instanceof Array?t:[t])).reduce(((t,e)=>[...t,...e]),[])}return Ke(t)?function(t){return t.split("\n").map((t=>t.match(/\(([^)]+)\)/)[1])).map(We)}(t):Xe(t)?function(t){return t.split("\n").map((t=>t.match(/\(([^)]+)\)/)[1])).map(je).reduce(((t,e)=>[...t,...e]),[])}(t):[]}function Ke(t){return t.split("\n")?.every((t=>t.includes("POINT")))}function Xe(t){return t.split("\n")?.every((t=>t.includes("LINESTRING")))}function tn(t){return t.startsWith("POINT")||Ke(t)||t.startsWith("LINESTRING")||Xe(t)||t.startsWith("MULTILINESTRING")||t.startsWith("POLYGON")||t.startsWith("MULTIPOINT")||t.startsWith("MULTIPOLYGON")||t.startsWith("GEOMETRYCOLLECTION")}y.isWktString=tn,y.parseWKT=Je,y.BooleanOperations=Yt,y.Relations=se;export{Ie as Arc,o as BOUNDARY,Yt as BooleanOperations,Te as Box,t as CCW,e as CW,ye as Circle,qe as Distance,Ae as Edge,w as Errors,Ne as Face,r as INSIDE,Ve as Inversion,ve as Line,oe as Matrix,rt as Multiline,n as ORIENTATION,s as OUTSIDE,l as OVERLAP_OPPOSITE,a as OVERLAP_SAME,ce as PlanarSet,ue as Point,Ce as Polygon,Oe as Ray,se as Relations,me as Segment,_t as SmartIntersections,E as Utils,de as Vector,be as arc,Pe as box,we as circle,y as default,Fe as inversion,tn as isWktString,Ee as line,ae as matrix,st as multiline,Je as parseWKT,pe as point,Ue as polygon,Le as ray,Jt as ray_shoot,_e as segment,ge as vector};
